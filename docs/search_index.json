[
["modelos-conceptos-basicos.html", "18 Modelos: conceptos básicos 18.1 Paquetes necesarios 18.2 Un modelo simple 18.3 Visualizando modelos 18.4 Fórmulas y familias de modelos", " 18 Modelos: conceptos básicos 18.1 Paquetes necesarios library(tibble) library(ggplot2) library(purrr) library(datos) 18.2 Un modelo simple 18.2.1 Ejercicios Una desventaja del modelo lineal es ser sensible a valores inusuales debido a que la distancia incorpora un término al cuadrado. Ajusta un modelo a los datos simulados que se presentan a continuación y visualiza los resultados. Corre el modelo varias veces para generar diferentes conjuntos de datos simulados. ¿Qué puedes observar respecto del modelo? sim1a &lt;- tibble( x = rep(1:10, each = 3), y = x * 1.5 + 6 + rt(length(x), df = 2) ) Solución Se puede correr una vez y graficar los resultados. ggplot(sim1a, aes(x = x, y = y)) + geom_point() + geom_smooth(method = &quot;lm&quot;, se = FALSE) Para sistematizarlo, se pueden generar varias simulaciones y luego graficar las líneas. simt &lt;- function(i) { tibble( x = rep(1:10, each = 3), y = x * 1.5 + 6 + rt(length(x), df = 2), .id = i ) } sims &lt;- map_df(1:12, simt) ggplot(sims, aes(x = x, y = y)) + geom_point() + geom_smooth(method = &quot;lm&quot;, colour = &quot;red&quot;) + facet_wrap(~.id, ncol = 4) El ejercicio usa la función rt() la cual entrega un muestreo a partir de una distribución t-Student, la cual tiene colas más largas que la distribución normal (rnorm()), por lo tanto asigna una mayor probabilidad a los valores fuera del centro de la distribución. ¿Qué ocurre si usamos una distribución normal? sim_norm &lt;- function(i) { tibble( x = rep(1:10, each = 3), y = x * 1.5 + 6 + rnorm(length(x)), .id = i ) } simdf_norm &lt;- map_df(1:12, sim_norm) ggplot(simdf_norm, aes(x = x, y = y)) + geom_point() + geom_smooth(method = &quot;lm&quot;, colour = &quot;red&quot;) + facet_wrap(~.id, ncol = 4) Al usar distribución normal no hay tantos valores extremos y las pendientes son más similares. Para el caso de la distribución normal con media cero y desviación estándar uno, la probabilidad de que un valor sea mayor a dos se obtiene con pnorm(). pnorm(2, lower.tail = FALSE) ## [1] 0.02275013 Para el caso de la distribución t-Student con dos grados de libertad, la probabilidad es más del triple del caso anterior y se obtiene con pt(). pt(2, df = 2, lower.tail = FALSE) ## [1] 0.09175171 Podemos concluir que el modelo es sensible a valores extremos y en general a la distribución que siguen los datos. Una forma de obtener un modelo lineal más robusto es usar una métrica distinta para la distancia. Por ejemplo, en lugar de la raíz de la distancia media cuadrática (del inglés root-mean-squared distance) se podría usar la media de la distancia absoluta: medir_distancia &lt;- function(modelo, datos) { diferencia &lt;- datos$y - modelo1(modelo, datos) mean(abs(diferencia)) } Usa optim() para ajustar este modelo a los datos simulados anteriormente y compara el resultado con el modelo lineal. Solución Usando los datos sim1a y optim() podemos encontrar los parámetros que minimizan la desviación absoluta. Definiremos la función modelo1() tal como se hizo en el libro. modelo1 &lt;- function(a, datos) { a[1] + datos$x * a[2] } beta &lt;- optim(c(0, 0), medir_distancia, datos = sim1a) beta$par ## [1] 5.963011 1.483554 Los resultados del modelo lineal son los mismos que se obtienen si se minimiza la desviación al cuadrado. medir_distancia_ml &lt;- function(modelo, datos) { diferencia &lt;- datos$y - (modelo[1] + modelo[2] * datos$x) sqrt(mean(diferencia^2)) } beta &lt;- optim(c(0, 0), medir_distancia_ml, datos = sim1a) beta$par ## [1] 10.76482916 0.06902913 En la práctica no es recomendable usar optim() para ajustar un modelo, es mejor utilizar implementaciones ya existentes como rlm() y lqs() que son parte del paquete MASS. La justificación es que estas implementaciones permiten ajustar modelos robustos sin los múltiples problemas de carácter numérico que pueden surgir de manera condicional a los datos al momento de usar optim(). Un desafío al realizar optimización numérica es que únicamente garantiza encontrar un óptimo local. ¿Qué problema se presenta al optimizar un modelo de tres parámetros como el que se presenta a continuación? modelo3 &lt;- function(a, datos) { a[1] + datos$x * a[2] + a[3] } Solución El problema es que dados los valores a[1] = a1 y a[3] = a3, cualquier otra combinación de a[1] y a[3] tal que a[1] + a[3] == (a1 + a3) tendrá el mismo ajuste. medir_distancia_3_ml &lt;- function(a, datos) { diferencia &lt;- datos$y - modelo3(a, datos) sqrt(mean(diferencia^2)) } Dependiendo de los valores inciales se van a obtener distintos valores óptimos. beta_000 &lt;- optim(c(0, 0, 0), medir_distancia_3_ml, datos = sim1a) beta_000$par ## [1] 7.24575368 0.06819655 3.52688780 beta_001 &lt;- optim(c(0, 0, 1), medir_distancia_3_ml, datos = sim1a) beta_001$par ## [1] -5.56232253 0.07011962 16.32207754 beta_005 &lt;- optim(c(0, 0, 5), medir_distancia_3_ml, datos = sim1a) beta_005$par ## [1] -0.60685386 0.06882549 11.37401608 Si seguimos alterando los valores inciales no es muy difícil concluir que existen infinitos valores óptimos para este modelo. 18.3 Visualizando modelos 18.3.1 Ejercicios En lugar de usar lm() para ajustar una línea recta, puedes usar loess() para ajustar una curva suave. Repite el proceso de ajustar el modelo, generar la cuadrícula, predicciones y visualización con sim1 usando loess() en vez de lm(). ¿Cómo se compara el resultado a geom_smooth(). add_predictions() está pareada con gather_predictions() y spread_predictions(). ¿Cómo difieren estas tres funciones? ¿Qué hace geom_ref_line()? ¿De qué paquete proviene? ¿Por qué es útil e importante incluir una línea de referencia en los gráficos que muestran residuos? ¿Por qué quisieras mirar un polígono de frecuencias con los residuos absolutos? ¿Cuáles son las ventajas y desventajas de los residuos crudos? 18.4 Fórmulas y familias de modelos 18.4.1 Ejercicios ¿Qué pasa si repites el análisis de sim2 usando un modelo sin intercepto? ¿Qué ocurre con la ecuación del modelo? ¿Qué ocurre con las predicciones? Usa model_matrix() para explorar las ecuaciones generadas por los modelos ajustados a sim3 y sim4. ¿Por qué * es un atajo para la interacción? Usando los principios básicos, convierte las fórmulas de los siguientes modelos en funciones. (Sugerencia: comienza por convertir las variables categóricas en ceros y unos.) mod1 &lt;- lm(y ~ x1 + x2, data = sim3) mod2 &lt;- lm(y ~ x1 * x2, data = sim3) Para sim4, ¿Es mejor mod1 o mod2? Yo creo que mod2 es ligeramente mejor removiendo las tendencias, pero es bastante sutil. ¿Puedes generar un gráfico que de sustento a esta hipótesis? "]
]
