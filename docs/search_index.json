[
["cadenas-de-caracteres.html", "14 Cadenas de caracteres 14.2 Cadenas: elementos básicos 14.3 Herramientas 14.4 Otro tipo de patrones 14.6 stringi", " 14 Cadenas de caracteres 14.2 Cadenas: elementos básicos 14.2.5 Ejercicios En ejemplos de código en los que no se utiliza stringr, verás usualmente paste() y paste0() (paste = pegar). ¿Cuál es la diferencia entre estas dos funciones? ¿A qué función de stringr son equivalentes? ¿Cómo difieren estas dos funciones respecto de su manejo de los NA? Solución paste() y paste0() se diferencian en la opción por defecto para separar los elementos que se concatenan. paste() deja un espacio; paste0() no. paste(&quot;uno&quot;, &quot;dos&quot;, &quot;tres&quot;) #&gt; [1] &quot;uno dos tres&quot; paste0(&quot;uno&quot;, &quot;dos&quot;, &quot;tres&quot;) #&gt; [1] &quot;unodostres&quot; Estas funciones son equivalentes a str_c(). Esta función por defecto no agrega un espacio entre los elementos concatenados, por lo que si queremos incluirlo es necesario explicitarlo con el argumento sep =: str_c(&quot;uno&quot;, &quot;dos&quot;, &quot;tres&quot;) #&gt; [1] &quot;unodostres&quot; str_c(&quot;uno&quot;, &quot;dos&quot;, &quot;tres&quot;, sep = &quot; &quot;) #&gt; [1] &quot;uno dos tres&quot; Si str_c() se encuentra un NA entrega como resultado NA. paste(), en cambio, paste() y paste0() lo concatenan. str_c(&quot;uno&quot;, &quot;dos&quot;, NA, sep = &quot; &quot;) #&gt; [1] NA paste(&quot;uno&quot;, &quot;dos&quot;, NA) #&gt; [1] &quot;uno dos NA&quot; Describe con tus propias palabras la diferencia entre los argumentos sep y collapse de la función str_c(). Solución sep define el caracter que se inserta entre los elementos a concatenar. collapse, por su parte, es el caracter para combinar entre los elementos a concatenar para generar un vector de extensión 1: x &lt;- c(&quot;uno&quot;, &quot;dos&quot;, &quot;tres&quot;) y &lt;- c(&quot;cuatro&quot;, &quot;cinco&quot;, &quot;seis&quot;) str_c(x, sep = &quot;-&quot;) #&gt; [1] &quot;uno&quot; &quot;dos&quot; &quot;tres&quot; str_c(x, collapse = &quot;-&quot;) #&gt; [1] &quot;uno-dos-tres&quot; str_c(x, y, sep = &quot;-&quot;) #&gt; [1] &quot;uno-cuatro&quot; &quot;dos-cinco&quot; &quot;tres-seis&quot; str_c(x, y, collapse = &quot;-&quot;) #&gt; [1] &quot;unocuatro-doscinco-tresseis&quot; Utiliza str_length() y str_sub() para extraer el caracter del medio de una cadena. ¿Qué harías si el número de caracteres es par? Solución x &lt;- c(&quot;uno&quot;, &quot;dos&quot;, &quot;tres&quot;) largo &lt;- str_length(x) mitad &lt;- ceiling(largo / 2) str_sub(x, start = mitad, end = mitad) #&gt; [1] &quot;n&quot; &quot;o&quot; &quot;r&quot; ¿Qué hace str_wrap()? (wrap = envolver) ¿Cuándo podrías querer utilizarla? Solución str_wrap() permite formatear párrafos indicando el ancho en cantidad de caracteres que queremos que tenga. El valor por defecto es 80. texto &lt;- &quot;Lorem ipsum dolor sit amet, consectetur adipiscing elit. Mauris in risus magna. Nulla consequat imperdiet nisl sit amet euismod. Sed nec molestie velit, non cursus neque. Suspendisse dapibus, justo at convallis pulvinar, nibh neque congue lectus, nec sollicitudin libero lacus eget nisl. Vivamus cursus turpis id quam aliquam, et fermentum tellus lacinia. Aliquam a eros nunc. Pellentesque habitant morbi tristique senectus et netus et malesuada fames ac turpis egestas. Nunc finibus auctor auctor.&quot; str_wrap(texto) #&gt; [1] &quot;Lorem ipsum dolor sit amet, consectetur adipiscing elit. Mauris in risus magna.\\nNulla consequat imperdiet nisl sit amet euismod. Sed nec molestie velit, non\\ncursus neque. Suspendisse dapibus, justo at convallis pulvinar, nibh neque\\ncongue lectus, nec sollicitudin libero lacus eget nisl. Vivamus cursus turpis\\nid quam aliquam, et fermentum tellus lacinia. Aliquam a eros nunc. Pellentesque\\nhabitant morbi tristique senectus et netus et malesuada fames ac turpis egestas.\\nNunc finibus auctor auctor.&quot; str_wrap(texto, width = 40) #&gt; [1] &quot;Lorem ipsum dolor sit amet, consectetur\\nadipiscing elit. Mauris in risus magna.\\nNulla consequat imperdiet nisl sit amet\\neuismod. Sed nec molestie velit, non\\ncursus neque. Suspendisse dapibus, justo\\nat convallis pulvinar, nibh neque congue\\nlectus, nec sollicitudin libero lacus\\neget nisl. Vivamus cursus turpis id quam\\naliquam, et fermentum tellus lacinia.\\nAliquam a eros nunc. Pellentesque\\nhabitant morbi tristique senectus et\\nnetus et malesuada fames ac turpis\\negestas. Nunc finibus auctor auctor.&quot; str_wrap(texto, width = 40, indent = 3) #&gt; [1] &quot; Lorem ipsum dolor sit amet, consectetur\\nadipiscing elit. Mauris in risus magna.\\nNulla consequat imperdiet nisl sit amet\\neuismod. Sed nec molestie velit, non\\ncursus neque. Suspendisse dapibus, justo\\nat convallis pulvinar, nibh neque congue\\nlectus, nec sollicitudin libero lacus\\neget nisl. Vivamus cursus turpis id quam\\naliquam, et fermentum tellus lacinia.\\nAliquam a eros nunc. Pellentesque\\nhabitant morbi tristique senectus et\\nnetus et malesuada fames ac turpis\\negestas. Nunc finibus auctor auctor.&quot; ¿Qué hace str_trim()? (trim = recortar) ¿Cuál es el opuesto de str_trim()? Solución str_trim() permite eliminar espacios en blanco al inicio y al final de una cadena de caracteres: str_trim(&quot; palabra &quot;) #&gt; [1] &quot;palabra&quot; str_trim(&quot; palabra &quot;, side = &quot;left&quot;) #&gt; [1] &quot;palabra &quot; str_trim(&quot; palabra &quot;, side = &quot;right&quot;) #&gt; [1] &quot; palabra&quot; La función opuesta es str_pad(): str_pad(&quot;palabra&quot;, width = 15) #&gt; [1] &quot; palabra&quot; str_pad(&quot;palabra&quot;, width = 15, side = &quot;right&quot;) #&gt; [1] &quot;palabra &quot; str_pad(&quot;palabra&quot;, width = 15, side = &quot;both&quot;) #&gt; [1] &quot; palabra &quot; Escribe una función que convierta, por ejemplo, el vector c(\"a\", \"b\", \"c\") en la cadena a, b y c. Piensa con detención qué debería hacer dado un vector de largo 0, 1, o 2. Solución Necesitamos crear una función que tome un vector de caracteres y lo convierta en una oración enumerativa. Cuando el vector tiene un largo mayor a 2, deberá separar los elementos con coma, excepto el último, que debe separarse con “y”. Por ejemplo: a, b, c, d y e. Si su largo es 2, solo los deberá separar con “y”: a y b. Si su largo es 1, solo debería devolver ese único elemento: a. Si es de largo 0, debería devolver una cadena vacía: \"\". y &lt;- c(&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;) str_enumeracion &lt;- function(x, delim = &quot;,&quot;) { n &lt;- length(x) if (n == 0) { &quot;&quot; } else if (n == 1) { x } else if (n == 2) { # solo separar con &quot;y&quot; str_c(x[[1]], &quot;y&quot;, x[[2]], sep = &quot; &quot;) } else { # separar con comas todos los elementos, excepto los dos último, que llevan una &quot;y&quot; str_c(c(str_c(x[seq_len(n - 2)], delim), str_c(x[[n-1]], &quot;y&quot;, x[[n]], sep = &quot; &quot;)), collapse = &quot; &quot;) } } Ahora, probemos la función con c(\"a\", \"b\", \"c\"): str_enumeracion(c(&quot;a&quot;, &quot;b&quot;, &quot;c&quot;)) #&gt; [1] &quot;a, b y c&quot; Veamos qué pasa cuando son menos y cuando son más elementos en la cadena: str_enumeracion(&quot;&quot;) #&gt; [1] &quot;&quot; str_enumeracion(&quot;a&quot;) #&gt; [1] &quot;a&quot; str_enumeracion(c(&quot;a&quot;, &quot;b&quot;)) #&gt; [1] &quot;a y b&quot; str_enumeracion(c(&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;, &quot;e&quot;)) #&gt; [1] &quot;a, b, c, d y e&quot; 14.2.6 Buscar coincidencia de patrones con expresiones regulares 14.2.7.1 Ejercicios Explica por qué cada una de estas cadenas no coincide con \\: \"\\\", \"\\\\\", \"\\\\\\\". Solución Como se menciona en el capítulo, tenemos que distinguir entre expresiones regulares y las cadenas de caracteres que la representan. La expresión regular que permite buscar una coincidencia con \\ es \\\\, ya que tenemos que escapar la barra invertida con otra barra invertida para que sea interpretada de manera literal. Pero para que R interprete esas dos barras como la expresión regular para coincidir con \\ en una cadena de caracteres, tenemos que escapar ambas, es decir \"\\\\\\\\\". Usar una sola barra invertida dentro de una cadena escapa el siguiente caracter. writeLines(&quot;una comilla\\&quot;&quot;) #&gt; una comilla&quot; Dos barras invertidas se interpretan como una expresión regular que escapará el siguiente caracter. x &lt;- &quot;¿aló?&quot; str_view(x, &quot;\\\\?&quot;) Tres barras invertidas en una cadena permiten escapar una barra y el siguiente caracter escapado para poder coincidir con este último: y &lt;- &quot;una barra seguida de una comilla: \\\\\\&quot;&quot; str_view(y, &quot;\\\\\\&quot;&quot;) ¿Cómo harías coincidir la secuencia \"'\\? Solución Primero, para generar esa secuencia tenemos que escapar las comillas y la barra invertida usando barras invertidas: x &lt;- &quot;\\&quot;&#39;\\\\&quot; writeLines(x) #&gt; &quot;&#39;\\ Para buscar la coincidencia: str_view(x, &quot;\\\\\\&quot;&#39;\\\\\\\\&quot;) ¿Con qué patrones coincidiría la expresión regular\\..\\..\\..? ¿Cómo la representarías en una cadena? Solución Esa expresión regular repite tres veces el mismo patrón: escapa un punto para que sea interpretado de manera literal y luego utiliza un punto para hacer coincidir cualquier caracter. Por lo tanto, coincidiría con patrones como: .a.b.c, .1.r.3, .#. .!. x &lt;- c(&quot;abc.d.e.f&quot;, &quot;.1. .3&quot;, &quot;.a.b.c&quot;, &quot;\\\\.\\\\.\\\\.&quot;) str_view(x, &quot;\\\\..\\\\..\\\\..&quot;) 14.2.8 Anclas 14.2.8.1 Ejercicios ¿Cómo harías coincidir la cadena \"$^$\" de manera literal? Solución x &lt;- &quot;$^$&quot; str_view(x, &quot;\\\\$\\\\^\\\\$&quot;) Dado el corpus de palabras comunes en datos::palabras, crea una expresión regular que busque palabras: Empiecen con “y”. Terminen con “x” Tengan una extensión de exactamente tres letras. (¡No hagas trampa usando str_length()!) Tengan siete letras o más. Dado que esta será una lista larga, podrías quere usar el argumento match en str_view() para mostrar solo las palabras que coincidan o no coincidan. Solución Las palabras que empiezan con “y” podemos buscarlas utilizando el ancla de inicio de cadena: str_view(palabras, &quot;^y&quot;, match = TRUE) Las palabras que terminen con “z” podemos buscarlas utilizando el ancla de final de cadena: str_view(palabras, &quot;z$&quot;, match = TRUE) Las que tienen una extensión de 3 letras podemos buscarlas usando tres .. Pero para que solo coincida con aquellas que tienen una extensión igual a 3, tenemos que usar anclas al inicio y final de la cadena: str_view(palabras, &quot;^...$&quot;, match = TRUE) Para buscar palabras con 8 letras o más, podemos seguir la misma lógica del caso anterior, pero esta vez sin las anclas: str_view(palabras, &quot;........&quot;, match = TRUE) 14.2.9 Clases de caracteres y alternativas 14.2.9.1 Ejercicios Crea una expresión regular que encuentre todas las palabras que: Empiecen con una vocal. Solo contengan consonantes. (Pista: piensa en cómo buscar coincidencias para “no”-vocales.) Terminen en ón, pero no en ión. Terminen con ndo o ado. Solución Para buscar todas las palabras que empiecen con vocal utilizaremos str_subset() porque son muchos resultados: str_subset(palabras, &quot;^[aáeéiíoóuúü]&quot;) #&gt; [1] &quot;a&quot; &quot;abril&quot; &quot;acción&quot; &quot;acciones&quot; #&gt; [5] &quot;acerca&quot; &quot;actitud&quot; &quot;actividad&quot; &quot;actividades&quot; #&gt; [9] &quot;acto&quot; &quot;actual&quot; &quot;acuerdo&quot; &quot;adelante&quot; #&gt; [13] &quot;además&quot; &quot;administración&quot; &quot;afirmó&quot; &quot;agua&quot; #&gt; [17] &quot;ahí&quot; &quot;ahora&quot; &quot;aire&quot; &quot;al&quot; #&gt; [21] &quot;algo&quot; &quot;alguien&quot; &quot;algún&quot; &quot;alguna&quot; #&gt; [25] &quot;algunas&quot; &quot;algunos&quot; &quot;allá&quot; &quot;allí&quot; #&gt; [29] &quot;alrededor&quot; &quot;alta&quot; &quot;alto&quot; &quot;ambiente&quot; #&gt; [33] &quot;ambos&quot; &quot;américa&quot; &quot;amigo&quot; &quot;amigos&quot; #&gt; [37] &quot;amor&quot; &quot;análisis&quot; &quot;animales&quot; &quot;ante&quot; #&gt; [41] &quot;anterior&quot; &quot;antes&quot; &quot;antonio&quot; &quot;año&quot; #&gt; [45] &quot;años&quot; &quot;aparece&quot; &quot;apenas&quot; &quot;apoyo&quot; #&gt; [49] &quot;aquel&quot; &quot;aquella&quot; &quot;aquellas&quot; &quot;aquellos&quot; #&gt; [53] &quot;aquí&quot; &quot;área&quot; &quot;argentina&quot; &quot;armas&quot; #&gt; [57] &quot;arriba&quot; &quot;arte&quot; &quot;artículo&quot; &quot;así&quot; #&gt; [61] &quot;asimismo&quot; &quot;asociación&quot; &quot;aspecto&quot; &quot;aspectos&quot; #&gt; [65] &quot;asunto&quot; &quot;atención&quot; &quot;atrás&quot; &quot;aumento&quot; #&gt; [69] &quot;aun&quot; &quot;aún&quot; &quot;aunque&quot; &quot;autor&quot; #&gt; [73] &quot;autoridades&quot; &quot;ayer&quot; &quot;ayuda&quot; &quot;e&quot; #&gt; [77] &quot;economía&quot; &quot;económica&quot; &quot;económico&quot; &quot;edad&quot; #&gt; [81] &quot;educación&quot; &quot;efecto&quot; &quot;efectos&quot; &quot;ejemplo&quot; #&gt; [85] &quot;ejército&quot; &quot;el&quot; &quot;él&quot; &quot;elecciones&quot; #&gt; [89] &quot;electoral&quot; &quot;elementos&quot; &quot;ella&quot; &quot;ellas&quot; #&gt; [93] &quot;ello&quot; &quot;ellos&quot; &quot;embargo&quot; &quot;empresa&quot; #&gt; [97] &quot;empresas&quot; &quot;en&quot; &quot;encima&quot; &quot;encontrar&quot; #&gt; [101] &quot;encuentra&quot; &quot;encuentran&quot; &quot;encuentro&quot; &quot;energía&quot; #&gt; [105] &quot;enero&quot; &quot;enfermedad&quot; &quot;entonces&quot; &quot;entrada&quot; #&gt; [109] &quot;entrar&quot; &quot;entre&quot; &quot;época&quot; &quot;equipo&quot; #&gt; [113] &quot;era&quot; &quot;eran&quot; &quot;es&quot; &quot;esa&quot; #&gt; [117] &quot;esas&quot; &quot;escuela&quot; &quot;ese&quot; &quot;esfuerzo&quot; #&gt; [121] &quot;eso&quot; &quot;esos&quot; &quot;espacio&quot; &quot;españa&quot; #&gt; [125] &quot;español&quot; &quot;española&quot; &quot;españoles&quot; &quot;especial&quot; #&gt; [129] &quot;especialmente&quot; &quot;especie&quot; &quot;espera&quot; &quot;esta&quot; #&gt; [133] &quot;está&quot; &quot;ésta&quot; &quot;estaba&quot; &quot;estaban&quot; #&gt; [137] &quot;estado&quot; &quot;estados&quot; &quot;estamos&quot; &quot;están&quot; #&gt; [141] &quot;estar&quot; &quot;estas&quot; &quot;este&quot; &quot;éste&quot; #&gt; [145] &quot;estilo&quot; &quot;esto&quot; &quot;estos&quot; &quot;estoy&quot; #&gt; [149] &quot;estructura&quot; &quot;estudio&quot; &quot;estudios&quot; &quot;estuvo&quot; #&gt; [153] &quot;etapa&quot; &quot;etc&quot; &quot;europa&quot; &quot;europea&quot; #&gt; [157] &quot;evitar&quot; &quot;ex&quot; &quot;existe&quot; &quot;existen&quot; #&gt; [161] &quot;existencia&quot; &quot;éxito&quot; &quot;experiencia&quot; &quot;explicó&quot; #&gt; [165] &quot;expresión&quot; &quot;exterior&quot; &quot;i&quot; &quot;iba&quot; #&gt; [169] &quot;idea&quot; &quot;ideas&quot; &quot;iglesia&quot; &quot;igual&quot; #&gt; [173] &quot;ii&quot; &quot;imagen&quot; &quot;imágenes&quot; &quot;importancia&quot; #&gt; [177] &quot;importante&quot; &quot;importantes&quot; &quot;imposible&quot; &quot;incluso&quot; #&gt; [181] &quot;industria&quot; &quot;información&quot; &quot;informe&quot; &quot;instituciones&quot; #&gt; [185] &quot;instituto&quot; &quot;interés&quot; &quot;intereses&quot; &quot;interior&quot; #&gt; [189] &quot;internacional&quot; &quot;investigación&quot; &quot;ir&quot; &quot;izquierda&quot; #&gt; [193] &quot;o&quot; &quot;objetivo&quot; &quot;objeto&quot; &quot;obra&quot; #&gt; [197] &quot;obras&quot; &quot;obstante&quot; &quot;ocasión&quot; &quot;ocasiones&quot; #&gt; [201] &quot;ocho&quot; &quot;octubre&quot; &quot;oficial&quot; &quot;ojos&quot; #&gt; [205] &quot;operación&quot; &quot;opinión&quot; &quot;oposición&quot; &quot;orden&quot; #&gt; [209] &quot;organización&quot; &quot;origen&quot; &quot;oro&quot; &quot;otra&quot; #&gt; [213] &quot;otras&quot; &quot;otro&quot; &quot;otros&quot; &quot;u&quot; #&gt; [217] &quot;última&quot; &quot;último&quot; &quot;últimos&quot; &quot;un&quot; #&gt; [221] &quot;una&quot; &quot;unas&quot; &quot;única&quot; &quot;único&quot; #&gt; [225] &quot;unidad&quot; &quot;unidos&quot; &quot;unión&quot; &quot;universidad&quot; #&gt; [229] &quot;uno&quot; &quot;unos&quot; &quot;uso&quot; &quot;usted&quot; Para buscar palabras que solo tienen consonantes buscamos no-vocales que se repitan una o más veces (+) y anclamos el inicio y fin de la cadena. datos::palabras incluye algunas abreviaciones (por ejemplo, pp = páginas), por lo que junto con “y” es lo único que encontraremos. str_view(palabras, &quot;^[^aáeéiíoóuúü]+$&quot;, match = TRUE) Palabras que terminan en ón, pero no en ión. str_view(palabras, &quot;[^i]ón$&quot;, match = TRUE) Palabras que terminan con ndo o ado: str_view(palabras, &quot;(n|a)do&quot;, match = TRUE) ¿Siempre a una “q” la sigue una “u”? Solución Podemos buscar las “q” y ver qué las sigue: str_subset(palabras, &quot;q.&quot;) #&gt; [1] &quot;aquel&quot; &quot;aquella&quot; &quot;aquellas&quot; &quot;aquellos&quot; &quot;aquí&quot; &quot;aunque&quot; #&gt; [7] &quot;cualquier&quot; &quot;equipo&quot; &quot;izquierda&quot; &quot;pequeña&quot; &quot;pequeño&quot; &quot;porque&quot; #&gt; [13] &quot;que&quot; &quot;qué&quot; &quot;queda&quot; &quot;quedó&quot; &quot;quería&quot; &quot;quien&quot; #&gt; [19] &quot;quién&quot; &quot;quienes&quot; &quot;quiere&quot; &quot;quiero&quot; &quot;quizá&quot; &quot;siquiera&quot; O podemos buscar al revés: si a alguna “q” la sigue algo que no sea una “u”: str_subset(palabras, &quot;q[^u]&quot;) #&gt; character(0) Escribe una expresión regular que permita buscar un verbo que haya sido escrito usando voseo en segunda persona plural (por ejemplo, queréis en vez de quieren). Solución segunda_persona &lt;- c(&quot;queréis&quot;, &quot;quieren&quot;) str_view(segunda_persona, &quot;éis$&quot;, match = TRUE) Crea una expresión regular que coincida con la forma en que habitualmente se escriben los números de teléfono en tu país. Solución La respuesta varía según país y a veces dentro de un mismo país no siempre se usa un mismo formato. Para este ejercicio trataremos de encontrar este patrón: “(XX) XXX XX XX”, es decir, un código de ciudad entre paréntesis y el número separado en bloques de 3-2-2 dígitos con un espacio entre medio. Los dígitos pueden representarse como [0-9] o \\\\d telefonos &lt;- c(&quot;(32) 281 91 76&quot;, &quot;(32)2819176&quot;, &quot;(32)281 9176&quot;) str_view(telefonos, &quot;\\\\(\\\\d\\\\d\\\\) \\\\d\\\\d\\\\d \\\\d\\\\d \\\\d\\\\d&quot;) Este código podría simplificarse si es que utilizáramos algún modificador que nos permita controlar la repetición de patrones. En la próxima sesión se aborda este tema. En inglés existe una regla que dice que la letra i va siempre antes de la e, excepto cuando está después de una c\". Verifica empíricamente esta regla utilizando las palabras contenidas en stringr::words. Solución Para comprobar esta regla primero podríamos buscar si existe el patrón: cie str_subset(words, &quot;cie&quot;) #&gt; [1] &quot;science&quot; &quot;society&quot; ¡Hay dos palabras que indicarían que la excepción no se cumple siempre! ¿Y hay casos en los que la letra i va después de la e sin que esté precedida de una c? str_subset(words, &quot;[^c]ei&quot;) #&gt; [1] &quot;weigh&quot; Hay uno. Puede que estas sean excepciones, así que para ver qué tan frecuente es el patrón que indica la regla, busquemos las palabras en que sí se cumple str_subset(words, &quot;[^c]ie|cei&quot;) #&gt; [1] &quot;achieve&quot; &quot;believe&quot; &quot;brief&quot; &quot;client&quot; &quot;die&quot; #&gt; [6] &quot;experience&quot; &quot;field&quot; &quot;friend&quot; &quot;lie&quot; &quot;piece&quot; #&gt; [11] &quot;quiet&quot; &quot;receive&quot; &quot;tie&quot; &quot;view&quot; Son muchas más. 14.2.10 Repetición 14.2.10.1 Ejercicios Describe los equivalentes de ?, +, * en el formato {m,n}. Solución ? = {0,1} = una sola coincidencia + = {1,} = uno o más coincidencias * = {0,}= cero o más coincidencias Describe en palabras con qué coincidiría cada una de estas expresiones regulares: (lee con atención para ver si estamos utilizando una expresión regular o una cadena que define una expresión regular.) ^.*$ \"\\\\{.+\\\\}\" \\d{4}-\\d{2}-\\d{2} \"\\\\\\\\{4}\" Solución ^.*$: es una expresión regular que coincidiría con cualquier cadena de caracteres, incluso si no tiene nada en su interior. La expresión regular buscar cualquier caracter (.) que aparezca 0 o más veces (*) al inicio (^) o al final $ de una cadena de caracteres: cadena &lt;- c(&quot;123&quot;, &quot;una palabra&quot;, &quot;estas son cuatro palabras&quot;, &quot; &quot;, &quot;&quot;) str_match(cadena, &quot;^.*$&quot;) #&gt; [,1] #&gt; [1,] &quot;123&quot; #&gt; [2,] &quot;una palabra&quot; #&gt; [3,] &quot;estas son cuatro palabras&quot; #&gt; [4,] &quot; &quot; #&gt; [5,] &quot;&quot; \"\\\\{.+\\\\}\": es la cadena que representa una expresión regular coincidiría con {} y lo que tengan dentro, siempre que tenga al menos un caracter (.+): cadena &lt;- c(&quot;uno {dos} tres&quot;, &quot;uno {} tres&quot;, &quot;uno {2} tres&quot;) str_view(cadena, &quot;\\\\{.+\\\\}&quot;) La expresión regular \\d{4}-\\d{2}-\\d{2} coincide con secuencias de 4, 2 y 2 dígitos separados por un guión. numeros &lt;- c(&quot;4444-22-22&quot;, &quot;333-22-22&quot;, &quot;88888888&quot;) str_view(numeros, &quot;\\\\d{4}-\\\\d{2}-\\\\d{2}&quot;) La cadena “\\\\{4}” coincidiría con una barra invertida repetida 4 veces: barras &lt;- c(&quot;\\\\&quot;, &quot;\\\\\\\\&quot;, &quot;\\\\\\\\\\\\&quot;, &quot;\\\\\\\\\\\\\\\\&quot;) str_view(barras, &quot;\\\\\\\\{4}&quot;) Crea expresiones regulares para buscar todas las palabras que: Empiecen con dos consonantes. Tengan tres o más vocales seguidas. Tengan tres o más pares de vocal-consonante seguidos. Solución Para buscar palabras que empiecen con dos consonantes buscaremos la repetición de no-vocales al inicio de una cadena: str_view(palabras, &quot;^[^aáeéiíoóuúü]{2}&quot;, match = TRUE) Palabras con tres o más vocales seguidas str_view(palabras, &quot;[aáeéiíoóuúü]{3,}&quot;, match = TRUE) Palabras que tengan tres o más pares de vocal-consonante seguidos: str_view(palabras, &quot;([aáeéiíoóuúü][^aáeéiíoóuúü]){3,}&quot;, match = TRUE) 14.2.11 Agrupamiento y referencias previas 14.2.11.1 Ejercicios Describe en palabras con qué coinciden estas expresiones: (.)\\1\\1 \"(.)(.)\\\\2\\\\1\" (..)\\1 \"(.).\\\\1.\\\\1\" \"(.)(.)(.).*\\\\3\\\\2\\\\1\" Solución La expresión regular (.)\\1\\1 coincide con cualquier caracter repetido tres veces seguidas. str_view(c(&quot;a&quot;, &quot;aa&quot;, &quot;aaa&quot;, &quot;aaaa&quot;), &quot;(.)\\\\1\\\\1&quot;) La cadena \"(.)(.)\\\\2\\\\1\" coincide con los dos caracteres capturados seguidos de los mismos dos caracteres pero en orden inverso: str_view(c(&quot;abba&quot;, &quot;abab&quot;), &quot;(.)(.)\\\\2\\\\1&quot;) La expresión regular (..)\\1 coincide con un par de letras que se repite dos veces: str_view(c(&quot;abba&quot;, &quot;abab&quot;), &quot;(..)\\\\1&quot;) La cadena \"(.).\\\\1.\\\\1\" coicide con la secuencia: caracter capturado, otro caracter, caracter capturado, otro caracter, caracter capturado: str_view(c(&quot;babab&quot;, &quot;babeb&quot;, &quot;abab&quot;), &quot;(.).\\\\1.\\\\1&quot;) La cadena \"(.)(.)(.).*\\\\3\\\\2\\\\1\" coincide con los tres caracteres capturados, cero o más de otros caracteres y luego los tres caracteres capturados en orden inverso: str_view(c(&quot;abcdefgcba&quot;, &quot;abccba&quot;, &quot;abcabc&quot;), &quot;(.)(.)(.).*\\\\3\\\\2\\\\1&quot;) Construye una expresión regular que coincida con palabras que: Empiecen y terminen con el mismo caracter. Contengan un par de letras repetido (p. ej. “nacional” tiene “na” repetidos dos veces.) Contengan una letra repetida en al menos tres lugares (p. ej. “característica” tiene tres “a”.) Solución Para buscar palabras que empiecen y terminen con el mismo caracter: str_subset(palabras, &quot;^(.).*\\\\1$&quot;) #&gt; [1] &quot;acerca&quot; &quot;agua&quot; &quot;ahora&quot; &quot;alguna&quot; #&gt; [5] &quot;alta&quot; &quot;américa&quot; &quot;aquella&quot; &quot;argentina&quot; #&gt; [9] &quot;arriba&quot; &quot;ayuda&quot; &quot;entre&quot; &quot;ese&quot; #&gt; [13] &quot;especialmente&quot; &quot;especie&quot; &quot;este&quot; &quot;existe&quot; #&gt; [17] &quot;ii&quot; &quot;local&quot; &quot;ningún&quot; &quot;objetivo&quot; #&gt; [21] &quot;objeto&quot; &quot;ocho&quot; &quot;oro&quot; &quot;otro&quot; #&gt; [25] &quot;pp&quot; &quot;realizar&quot; &quot;sectores&quot; &quot;seis&quot; #&gt; [29] &quot;semanas&quot; &quot;servicios&quot; &quot;siguientes&quot; &quot;sistemas&quot; #&gt; [33] &quot;sociales&quot; &quot;somos&quot; &quot;sus&quot; Si bien el código permite encontrar lo que buscábamos, lo cierto es que ese patrón busca cadenas de caracteres que empiecen y terminen con el mismo caracter, no necesariamente una letra. Es decir, también coincidería con #455#. Si quisiéramos que solo encontrara letras: str_subset(palabras, &quot;^([:alpha:]).*\\\\1$&quot;) #&gt; [1] &quot;acerca&quot; &quot;agua&quot; &quot;ahora&quot; &quot;alguna&quot; #&gt; [5] &quot;alta&quot; &quot;américa&quot; &quot;aquella&quot; &quot;argentina&quot; #&gt; [9] &quot;arriba&quot; &quot;ayuda&quot; &quot;entre&quot; &quot;ese&quot; #&gt; [13] &quot;especialmente&quot; &quot;especie&quot; &quot;este&quot; &quot;existe&quot; #&gt; [17] &quot;ii&quot; &quot;local&quot; &quot;ningún&quot; &quot;objetivo&quot; #&gt; [21] &quot;objeto&quot; &quot;ocho&quot; &quot;oro&quot; &quot;otro&quot; #&gt; [25] &quot;pp&quot; &quot;realizar&quot; &quot;sectores&quot; &quot;seis&quot; #&gt; [29] &quot;semanas&quot; &quot;servicios&quot; &quot;siguientes&quot; &quot;sistemas&quot; #&gt; [33] &quot;sociales&quot; &quot;somos&quot; &quot;sus&quot; Palabras que contienen un par de letras repetido: str_subset(palabras, &quot;([:alpha:][:alpha:]).*\\\\1&quot;) #&gt; [1] &quot;alrededor&quot; &quot;análisis&quot; &quot;asociación&quot; &quot;características&quot; #&gt; [5] &quot;ciencia&quot; &quot;conciencia&quot; &quot;condiciones&quot; &quot;crisis&quot; #&gt; [9] &quot;desde&quot; &quot;económico&quot; &quot;encuentra&quot; &quot;encuentran&quot; #&gt; [13] &quot;encuentro&quot; &quot;españoles&quot; &quot;intereses&quot; &quot;internacional&quot; #&gt; [17] &quot;meses&quot; &quot;nacional&quot; &quot;nosotros&quot; &quot;participación&quot; #&gt; [21] &quot;particular&quot; &quot;respuesta&quot; &quot;tercera&quot; &quot;tienen&quot; #&gt; [25] &quot;vivir&quot; Palabras que contienen una letra repetida en al menos tres lugares: str_subset(palabras, &quot;([:alpha:]).*\\\\1.*\\\\1&quot;) #&gt; [1] &quot;administración&quot; &quot;campaña&quot; &quot;capacidad&quot; &quot;características&quot; #&gt; [5] &quot;carrera&quot; &quot;comunicación&quot; &quot;conciencia&quot; &quot;conocimiento&quot; #&gt; [9] &quot;consecuencia&quot; &quot;construcción&quot; &quot;diferentes&quot; &quot;elecciones&quot; #&gt; [13] &quot;elementos&quot; &quot;encuentran&quot; &quot;enfermedad&quot; &quot;especialmente&quot; #&gt; [17] &quot;especie&quot; &quot;experiencia&quot; &quot;generales&quot; &quot;instituciones&quot; #&gt; [21] &quot;instituto&quot; &quot;intereses&quot; &quot;internacional&quot; &quot;investigación&quot; #&gt; [25] &quot;mañana&quot; &quot;ministerio&quot; &quot;naturaleza&quot; &quot;ningún&quot; #&gt; [29] &quot;ninguna&quot; &quot;nosotros&quot; &quot;palabra&quot; &quot;palabras&quot; #&gt; [33] &quot;participación&quot; &quot;posibilidad&quot; &quot;posibilidades&quot; &quot;precisamente&quot; #&gt; [37] &quot;presente&quot; &quot;presidente&quot; &quot;principio&quot; &quot;principios&quot; #&gt; [41] &quot;septiembre&quot; &quot;sistemas&quot; &quot;trabajadores&quot; &quot;trabajar&quot; #&gt; [45] &quot;tratamiento&quot; 14.3 Herramientas 14.3.2 Ejercicios Para cada uno de los siguientes desafíos, intenta buscar una solución utilizando tanto una expresión regular simple como una combinación de múltiples llamadas a str_detect(). Encuentra todas las palabras que empiezan o terminan con y. Encuentra todas las palabras que empiezan con una vocal y terminan con una consonante. ¿Existen palabras que tengan todas las vocales? Solución Para encontrar todas las palabras que empiezan o terminan con y con una sola expresión regular: str_view(palabras, &quot;^y|y$&quot;, match = TRUE) Con múltiples llamadas a str_detect(): palabras[str_detect(palabras, &quot;^y&quot;) | str_detect(palabras, &quot;y$&quot;)] #&gt; [1] &quot;estoy&quot; &quot;hay&quot; &quot;hoy&quot; &quot;ley&quot; &quot;muy&quot; &quot;rey&quot; &quot;soy&quot; &quot;voy&quot; &quot;y&quot; #&gt; [10] &quot;ya&quot; &quot;yo&quot; Para encontrar todas las palabras que empiezan con una vocal y terminan con una consonante con una expresión regular: palabras %&gt;% str_subset(&quot;^[aáeéiíoóuúü].*[^aáeéiíoóuúü]$&quot;) %&gt;% head(n = 10) # son muchas así que miraremos las 10 primeras #&gt; [1] &quot;abril&quot; &quot;acción&quot; &quot;acciones&quot; &quot;actitud&quot; #&gt; [5] &quot;actividad&quot; &quot;actividades&quot; &quot;actual&quot; &quot;además&quot; #&gt; [9] &quot;administración&quot; &quot;al&quot; Con múltiples llamadas a str_detect(): palabras[str_detect(palabras, &quot;^[aáeéiíoóuú]&quot;) &amp; str_detect(palabras, &quot;[^aáeéiíoóuú]$&quot;)][1:10] #&gt; [1] &quot;abril&quot; &quot;acción&quot; &quot;acciones&quot; &quot;actitud&quot; #&gt; [5] &quot;actividad&quot; &quot;actividades&quot; &quot;actual&quot; &quot;además&quot; #&gt; [9] &quot;administración&quot; &quot;al&quot; ¿Existen palabras que tengan todas las vocales? Para resolver esto con una sola expresión regular: palabras[str_detect(palabras, &quot;(?=.*(a|á))(?=.*(e|é))(?=.*(i|í))(?=.*(o|o))(?=.*(u|ú|ü))&quot;)] #&gt; [1] &quot;autoridades&quot; &quot;consecuencia&quot; Con varias llamas a str_detect() palabras[str_detect(palabras, &quot;a|á&quot;) &amp; str_detect(palabras, &quot;e|é&quot;) &amp; str_detect(palabras, &quot;i|í&quot;) &amp; str_detect(palabras, &quot;o|o&quot;) &amp; str_detect(palabras, &quot;u|ú|ü&quot;)] #&gt; [1] &quot;autoridades&quot; &quot;consecuencia&quot; ¿Qué palabra tiene el mayor número de vocales? ¿Qué palabra tiene la mayor proporción de vocales? (Pista: ¿cuál es el denominador?) Solución Para responder esta pregunta tenemos que contar la cantidad de vocales y además calcular su proporción respecto del total de letras de la palabra. Hay varias formas de resolver esto. La que usaremos acá será crear un tibble y usar las funciones de stringr dentro de mutate: df &lt;- palabras %&gt;% tibble(palabra = .) %&gt;% mutate(largo = str_length(palabra)) %&gt;% mutate(vocales = str_count(palabra, &quot;[aáeéiíoóuúü]&quot;)) %&gt;% mutate(prop_vocales = vocales / largo) Ahora podemos responder las preguntas. Las palabras con más vocales en este set de datos tienen 6 en total. Son 15: top_n(df, 1, vocales) #&gt; # A tibble: 15 x 4 #&gt; palabra largo vocales prop_vocales #&gt; &lt;chr&gt; &lt;int&gt; &lt;int&gt; &lt;dbl&gt; #&gt; 1 administración 14 6 0.429 #&gt; 2 asociación 10 6 0.6 #&gt; 3 autoridades 11 6 0.545 #&gt; 4 características 15 6 0.4 #&gt; 5 comunicación 12 6 0.5 #&gt; 6 conocimiento 12 6 0.5 #&gt; # … with 9 more rows Hay palabras solo compuestas por vocales. Cuatro son efectivamente palabras (una preposición y tres conjunciones) y dos son vocales que se usan para numerar (“i”, “ii”): top_n(df, 1, prop_vocales) #&gt; # A tibble: 6 x 4 #&gt; palabra largo vocales prop_vocales #&gt; &lt;chr&gt; &lt;int&gt; &lt;int&gt; &lt;dbl&gt; #&gt; 1 a 1 1 1 #&gt; 2 e 1 1 1 #&gt; 3 i 1 1 1 #&gt; 4 ii 2 2 1 #&gt; 5 o 1 1 1 #&gt; 6 u 1 1 1 14.3.3 Extraer coincidencias 14.3.3.1 Ejercicios Te habrás dado cuenta que en el ejemplo anterior la expresión regular que utilizamos también devolvió como resultado “arrojo” y “azulejos”, que no son nombres de colores. Modifica la expresión regular para resolver ese problema. Solución En principio, para asegurarnos que solo busque nuestro patrón de manera exacta podríamos indicar límites de palabra con \\\\b. Con el inicio no tendríamos problemas y eso eliminaría “arrojo”. Sin embargo, si ponemos el límite de final de palabra no solo eliminaría “azulejo” sino también “verdes”. Para este ejemplo en particular no importa porque estamos buscando más de una coincidencia por cadena y “verdes” está en la misma cadena que azulajos (es decir, al eliminar esta última palabra queda un solo color en la cadena y por tanto que no responde a lo que estamos buscando). Pero si hubiese otro caso de color en plural sí tendríamos que modificar nuestro patrón. Una manera de resolver esto sería que nuestro patrón busque también las versiones en plural de los colores que indicamos. Y para hacerlo mejor aún, que busque también cuando el adjetivo sea femenino o masculino: # agregamos la opción de plural colores &lt;- c(&quot;roj(a|o)s*&quot;, &quot;amarill(a|o)s*&quot;, &quot;verde&quot;, &quot;azul(es)*&quot;, &quot;marr(o|ó)n&quot;) # agregamos límites de palabra al inicio y al final coincidencia_color &lt;- str_c(&quot;\\\\b(&quot;, str_c(colores, collapse = &quot;|&quot;), &quot;)\\\\b&quot;) tiene_color &lt;- str_subset(oraciones, coincidencia_color) mas &lt;- oraciones[str_count(oraciones, coincidencia_color) &gt; 1] str_view_all(mas, coincidencia_color) # chequear que encuentra también colores en plural y adjetivos femeninos en otros ejemplos: otras_oraciones &lt;- c(&quot;amarillas y rojas&quot;, &quot;rojas y azules&quot;) otras_oraciones[str_count(otras_oraciones, coincidencia_color) &gt; 1] #&gt; [1] &quot;amarillas y rojas&quot; &quot;rojas y azules&quot; De datos::oraciones extrae: La primera palabra de cada oración. Todas las palabras que terminen en ción. Todos los plurales. Solución Como cada oración es una cadena, podemos extraer la primera palabra de cada oración con \\\\w, que busca cualquier caracter de palabra con un ancla al inicio y un límite de palabra al final. Otra forma de buscar solo caracteres de palabras es con [:alpha:]: str_extract(oraciones, &quot;^(\\\\w+)\\\\b&quot;) #&gt; [1] &quot;Las&quot; &quot;La&quot; &quot;El&quot; &quot;Agrega&quot; &quot;Nueve&quot; #&gt; [6] &quot;Pega&quot; &quot;Instalaron&quot; &quot;Si&quot; &quot;Dos&quot; &quot;El&quot; #&gt; [11] &quot;Una&quot; &quot;Las&quot; &quot;Él&quot; &quot;La&quot; &quot;Había&quot; #&gt; [16] &quot;El&quot; &quot;El&quot; &quot;El&quot; &quot;Podían&quot; &quot;El&quot; #&gt; [21] &quot;Una&quot; &quot;Los&quot; &quot;El&quot; &quot;La&quot; &quot;El&quot; #&gt; [26] &quot;La&quot; &quot;El&quot; &quot;Recuéstate&quot; &quot;El&quot; &quot;Marca&quot; #&gt; [31] &quot;El&quot; &quot;La&quot; &quot;Ofreció&quot; &quot;Un&quot; &quot;El&quot; #&gt; [36] &quot;Una&quot; &quot;Dibuja&quot; &quot;La&quot; &quot;Pinta&quot; &quot;Despiértate&quot; #&gt; [41] &quot;La&quot; &quot;Puso&quot; &quot;El&quot; &quot;Corta&quot; &quot;Llovieron&quot; #&gt; [46] &quot;El&quot; &quot;El&quot; &quot;La&quot; &quot;El&quot; &quot;Cada&quot; str_extract(oraciones, &quot;^([:alpha:]+)\\\\b&quot;) #&gt; [1] &quot;Las&quot; &quot;La&quot; &quot;El&quot; &quot;Agrega&quot; &quot;Nueve&quot; #&gt; [6] &quot;Pega&quot; &quot;Instalaron&quot; &quot;Si&quot; &quot;Dos&quot; &quot;El&quot; #&gt; [11] &quot;Una&quot; &quot;Las&quot; &quot;Él&quot; &quot;La&quot; &quot;Había&quot; #&gt; [16] &quot;El&quot; &quot;El&quot; &quot;El&quot; &quot;Podían&quot; &quot;El&quot; #&gt; [21] &quot;Una&quot; &quot;Los&quot; &quot;El&quot; &quot;La&quot; &quot;El&quot; #&gt; [26] &quot;La&quot; &quot;El&quot; &quot;Recuéstate&quot; &quot;El&quot; &quot;Marca&quot; #&gt; [31] &quot;El&quot; &quot;La&quot; &quot;Ofreció&quot; &quot;Un&quot; &quot;El&quot; #&gt; [36] &quot;Una&quot; &quot;Dibuja&quot; &quot;La&quot; &quot;Pinta&quot; &quot;Despiértate&quot; #&gt; [41] &quot;La&quot; &quot;Puso&quot; &quot;El&quot; &quot;Corta&quot; &quot;Llovieron&quot; #&gt; [46] &quot;El&quot; &quot;El&quot; &quot;La&quot; &quot;El&quot; &quot;Cada&quot; Es posible encontrar también el siguiente patrón para representar caracteres de palabras: [a-z] o [A-Za-z] (para que busque mayúsculas también)- Sin embargo, hay que tener cuidado con su utilización en español, ya que no reconoce tildes. En este mismo ejemplo, nos devuelve NA en todas las palabras en las que hay tildes: str_extract(oraciones, &quot;^([A-Za-z]+)\\\\b&quot;) #&gt; [1] &quot;Las&quot; &quot;La&quot; &quot;El&quot; &quot;Agrega&quot; &quot;Nueve&quot; #&gt; [6] &quot;Pega&quot; &quot;Instalaron&quot; &quot;Si&quot; &quot;Dos&quot; &quot;El&quot; #&gt; [11] &quot;Una&quot; &quot;Las&quot; NA &quot;La&quot; NA #&gt; [16] &quot;El&quot; &quot;El&quot; &quot;El&quot; NA &quot;El&quot; #&gt; [21] &quot;Una&quot; &quot;Los&quot; &quot;El&quot; &quot;La&quot; &quot;El&quot; #&gt; [26] &quot;La&quot; &quot;El&quot; NA &quot;El&quot; &quot;Marca&quot; #&gt; [31] &quot;El&quot; &quot;La&quot; NA &quot;Un&quot; &quot;El&quot; #&gt; [36] &quot;Una&quot; &quot;Dibuja&quot; &quot;La&quot; &quot;Pinta&quot; NA #&gt; [41] &quot;La&quot; &quot;Puso&quot; &quot;El&quot; &quot;Corta&quot; &quot;Llovieron&quot; #&gt; [46] &quot;El&quot; &quot;El&quot; &quot;La&quot; &quot;El&quot; &quot;Cada&quot; 14.3.4 Coincidencias agrupadas 14.3.4.1 Ejercicios Busca en datos::oraciones todas las palabras que vengan después de un “número”, como “un(o|a)”, “dos”, “tres”, etc. Extrae tanto el número como la palabra. Solución Responderemos esta pregunta para números del 1 al 10 utilizando las dos formas recién vistas: str_match() y tidyr::extract(): numero_palabra &lt;- &quot;(una*o*|dos|tres|cuatro|cinco|seis|siete|ocho|nueve|diez) ([^ ]+)&quot; str_match(oraciones, numero_palabra) #&gt; [,1] [,2] [,3] #&gt; [1,] NA NA NA #&gt; [2,] NA NA NA #&gt; [3,] NA NA NA #&gt; [4,] NA NA NA #&gt; [5,] &quot;dos para&quot; &quot;dos&quot; &quot;para&quot; #&gt; [6,] NA NA NA #&gt; [7,] NA NA NA #&gt; [8,] NA NA NA #&gt; [9,] NA NA NA #&gt; [10,] NA NA NA #&gt; [11,] NA NA NA #&gt; [12,] NA NA NA #&gt; [13,] NA NA NA #&gt; [14,] NA NA NA #&gt; [15,] NA NA NA #&gt; [16,] NA NA NA #&gt; [17,] NA NA NA #&gt; [18,] &quot;dos pastillas.&quot; &quot;dos&quot; &quot;pastillas.&quot; #&gt; [19,] NA NA NA #&gt; [20,] NA NA NA #&gt; [21,] &quot;una ave&quot; &quot;una&quot; &quot;ave&quot; #&gt; [22,] NA NA NA #&gt; [23,] NA NA NA #&gt; [24,] &quot;una llama&quot; &quot;una&quot; &quot;llama&quot; #&gt; [25,] NA NA NA #&gt; [26,] NA NA NA #&gt; [27,] &quot;diez años.&quot; &quot;diez&quot; &quot;años.&quot; #&gt; [28,] NA NA NA #&gt; [29,] NA NA NA #&gt; [30,] &quot;un cartel&quot; &quot;un&quot; &quot;cartel&quot; #&gt; [31,] NA NA NA #&gt; [32,] NA NA NA #&gt; [33,] &quot;tres gráficos.&quot; &quot;tres&quot; &quot;gráficos.&quot; #&gt; [34,] &quot;un suéter&quot; &quot;un&quot; &quot;suéter&quot; #&gt; [35,] NA NA NA #&gt; [36,] NA NA NA #&gt; [37,] NA NA NA #&gt; [38,] NA NA NA #&gt; [39,] NA NA NA #&gt; [40,] NA NA NA #&gt; [41,] NA NA NA #&gt; [42,] NA NA NA #&gt; [43,] NA NA NA #&gt; [44,] &quot;una delgada&quot; &quot;una&quot; &quot;delgada&quot; #&gt; [45,] &quot;dos lados.&quot; &quot;dos&quot; &quot;lados.&quot; #&gt; [46,] NA NA NA #&gt; [47,] NA NA NA #&gt; [48,] NA NA NA #&gt; [49,] NA NA NA #&gt; [50,] NA NA NA tibble(oracion = oraciones) %&gt;% tidyr::extract( oracion, c(&quot;numero&quot;, &quot;palabra&quot;), numero_palabra, remove = FALSE ) %&gt;% filter(!is.na(palabra)) # solo ver las filas con resultados #&gt; # A tibble: 10 x 3 #&gt; oracion numero palabra #&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; #&gt; 1 Nueve hombres fueron contratados para excavar las ruinas. dos para #&gt; 2 El médico lo curó con estas dos pastillas. dos pastillas. #&gt; 3 Una grulla azul es una ave zancuda y alta. una ave #&gt; 4 La lámpara brillaba con una llama verde y continua. una llama #&gt; 5 El lazo púrpura tenía diez años. diez años. #&gt; 6 Marca el lugar con un cartel pintado de rojo. un cartel #&gt; # … with 4 more rows Para definir lo que es una palabra utilizamos la misma heurística propuesta en esta sección del libro, es decir, todo lo que no es un espacio. Sin embargo, esto hace que se extraigan también los puntos. Una manera de evitarlo es utilizar \\\\w: numero_palabra2 &lt;- &quot;(una*o*|dos|tres|cuatro|cinco|seis|siete|ocho|nueve|diez) (\\\\w+)&quot; tibble(oracion = oraciones) %&gt;% tidyr::extract( oracion, c(&quot;numero&quot;, &quot;palabra&quot;), numero_palabra2, remove = FALSE ) %&gt;% filter(!is.na(palabra)) # solo ver las filas con resultados #&gt; # A tibble: 10 x 3 #&gt; oracion numero palabra #&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; #&gt; 1 Nueve hombres fueron contratados para excavar las ruinas. dos para #&gt; 2 El médico lo curó con estas dos pastillas. dos pastillas #&gt; 3 Una grulla azul es una ave zancuda y alta. una ave #&gt; 4 La lámpara brillaba con una llama verde y continua. una llama #&gt; 5 El lazo púrpura tenía diez años. diez años #&gt; 6 Marca el lugar con un cartel pintado de rojo. un cartel #&gt; # … with 4 more rows En español a veces se utiliza el guión para unir adjetivos, establecer relaciones entre conceptos o para unir gentilicios (p. ej., teórico-práctico, precio-calidad, franco-porteño). ¿Cómo podrías encontrar esas palabras y separar lo que viene antes y después del guión? Solución Para separar las palabras podemos utilizar la función str_split() compuestas &lt;- c(&quot;teórico-práctico&quot;, &quot;precio-calidad&quot;, &quot;franco-porteño&quot;) tiene_guion &lt;- &quot;\\\\w+-\\\\w+&quot; str_extract(compuestas, tiene_guion) %&gt;% str_split(&quot;-&quot;) #&gt; [[1]] #&gt; [1] &quot;teórico&quot; &quot;práctico&quot; #&gt; #&gt; [[2]] #&gt; [1] &quot;precio&quot; &quot;calidad&quot; #&gt; #&gt; [[3]] #&gt; [1] &quot;franco&quot; &quot;porteño&quot; Si quisiéramos hacer esto mismo en el contexto de un data frame, podríamos utilizar la función tidyr::separate: tibble(palabras_compuestas = compuestas) %&gt;% tidyr::separate(palabras_compuestas, c(&quot;palabra1&quot;, &quot;palabra2&quot;), sep = &quot;-&quot;, remove = FALSE) # para no eliminar la columna original #&gt; # A tibble: 3 x 3 #&gt; palabras_compuestas palabra1 palabra2 #&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; #&gt; 1 teórico-práctico teórico práctico #&gt; 2 precio-calidad precio calidad #&gt; 3 franco-porteño franco porteño 14.3.5 Remplazar coincidencias 14.3.5.1 Ejercicios Remplaza en una cadena todas las barras por barras invertidas. Solución barras &lt;- &quot;una /, dos barras //, tres ///&quot; str_replace_all(barras, &quot;/&quot;, &quot;\\\\\\\\&quot;) %&gt;% writeLines() #&gt; una \\, dos barras \\\\, tres \\\\\\ Implementa una versón simple de str_to_lower() (a minúsculas) usando replace_all(). Solución Una manera sería buscar todas las mayúsculas y remplazarlas por su versión en minúcula. # Crear un vector con todos los remplazos: a_minuscula &lt;- c( &quot;A&quot; = &quot;a&quot;, &quot;Á&quot; = &quot;á&quot;, &quot;B&quot; = &quot;b&quot;, &quot;C&quot; = &quot;c&quot;, &quot;D&quot; = &quot;d&quot;, &quot;E&quot; = &quot;e&quot;, &quot;É&quot; = &quot;é&quot;,&quot;F&quot; = &quot;f&quot;, &quot;G&quot; = &quot;g&quot;, &quot;H&quot; = &quot;h&quot;, &quot;I&quot; = &quot;i&quot;, &quot;Í&quot; = &quot;í&quot;, &quot;J&quot; = &quot;j&quot;, &quot;K&quot; = &quot;k&quot;, &quot;L&quot; = &quot;l&quot;, &quot;M&quot; = &quot;m&quot;, &quot;N&quot; = &quot;n&quot;, &quot;Ñ&quot; = &quot;ñ&quot;,&quot;O&quot; = &quot;o&quot;, &quot;Ó&quot; = &quot;ó&quot;, &quot;P&quot; = &quot;p&quot;, &quot;Q&quot; = &quot;q&quot;, &quot;R&quot; = &quot;r&quot;, &quot;S&quot; = &quot;s&quot;, &quot;T&quot; = &quot;t&quot;, &quot;U&quot; = &quot;u&quot;, &quot;Ú&quot; = &quot;ú&quot;,&quot;V&quot; = &quot;v&quot;, &quot;W&quot; = &quot;w&quot;, &quot;X&quot; = &quot;x&quot;, &quot;Y&quot; = &quot;y&quot;, &quot;Z&quot; = &quot;z&quot;) mayusculas &lt;- c(&quot;Hola&quot;, &quot;Buenos días&quot;, &quot;Adiós&quot;) str_replace_all(mayusculas, pattern = a_minuscula) #&gt; [1] &quot;hola&quot; &quot;buenos días&quot; &quot;adiós&quot; Cambia la primera y la última letra en palabras. ¿Cuáles de esas cadenas siguen siendo palabras? Solución Primero, cambiemos la primera y la última letra. Para esto podemos utilizar grupos de captura y referencias previas. El patrón que queremos buscar son nuestros tres grupos de captura tendría que ser: 1. la primera letra (^([:alpha:])) 2. de la segunda a la penúltima letra ((.*)) 3. la última letra (([:alpha:])$) Luego, remplazamos con nuestro patrón con el primer y el último grupo invertido: \"\\\\3\\\\2\\\\1\" invertidas &lt;- str_replace_all(palabras, &quot;^([:alpha:])(.*)([:alpha:])$&quot;, &quot;\\\\3\\\\2\\\\1&quot;) head(invertidas) #&gt; [1] &quot;a&quot; &quot;lbria&quot; &quot;nccióa&quot; &quot;sccionea&quot; &quot;acerca&quot; &quot;dctitua&quot; La segunda pregunta es un poco amplia e implicaría revisar las 1000 palabras y evaluar en cada caso si es o no una palabra de nuestra lengua. Lo que sí podemos hacer es chequear si sigue siendo una palabra contenida en nuestro dataset palabras. Para ello, podemos utilizar dplyr::interset. Para eliminar las palabras y abreviaciones que tienen una sola letra (“y”, “a”, “o”, etc.), podemos comparar invertidas solo con las palabras de dos o más letras: intersect(invertidas, palabras[str_length(palabras) &gt; 1]) #&gt; [1] &quot;acerca&quot; &quot;agua&quot; &quot;ahora&quot; &quot;la&quot; #&gt; [5] &quot;alguna&quot; &quot;alta&quot; &quot;américa&quot; &quot;aquella&quot; #&gt; [9] &quot;argentina&quot; &quot;arriba&quot; &quot;ayuda&quot; &quot;le&quot; #&gt; [13] &quot;entre&quot; &quot;se&quot; &quot;ese&quot; &quot;especialmente&quot; #&gt; [17] &quot;especie&quot; &quot;este&quot; &quot;existe&quot; &quot;ii&quot; #&gt; [21] &quot;al&quot; &quot;el&quot; &quot;local&quot; &quot;sol&quot; #&gt; [25] &quot;ningún&quot; &quot;son&quot; &quot;objetivo&quot; &quot;objeto&quot; #&gt; [29] &quot;ocho&quot; &quot;oro&quot; &quot;otro&quot; &quot;pp&quot; #&gt; [33] &quot;realizar&quot; &quot;es&quot; &quot;sectores&quot; &quot;seis&quot; #&gt; [37] &quot;semanas&quot; &quot;servicios&quot; &quot;siguientes&quot; &quot;sistemas&quot; #&gt; [41] &quot;sociales&quot; &quot;los&quot; &quot;somos&quot; &quot;nos&quot; #&gt; [45] &quot;sus&quot; 14.3.6 Divisiones 14.3.6.1 Ejercicios Divide una cadena como \"manzanas, peras y bananas\" en elementos individuales. Solución x &lt;- c(&quot;manzanas, peras y bananas&quot;) str_split(x, &quot;(, )|( y )&quot;) #&gt; [[1]] #&gt; [1] &quot;manzanas&quot; &quot;peras&quot; &quot;bananas&quot; ¿Por qué es mejor dividir utilizando boundary(\"palabra\") en vez de \" \"? Solución El ejemplo que aparece en el libro muestra uno de los problemas de \" \": no elimina la puntuación. Es decir, no es capaz de indentificar claramente los límites de una palabra. boundary(\"word\") no tiene ese problema. x &lt;- &quot;Esta es una oración. Esta es otra oración&quot; str_split(x, &quot; &quot;)[[1]] #&gt; [1] &quot;Esta&quot; &quot;es&quot; &quot;una&quot; &quot;oración.&quot; &quot;Esta&quot; &quot;es&quot; &quot;otra&quot; #&gt; [8] &quot;oración&quot; str_split(x, boundary(&quot;word&quot;))[[1]] #&gt; [1] &quot;Esta&quot; &quot;es&quot; &quot;una&quot; &quot;oración&quot; &quot;Esta&quot; &quot;es&quot; &quot;otra&quot; #&gt; [8] &quot;oración&quot; ¿Qué pasa si dividimos con una cadena vacía (\"\")? Experimenta y luego lee la documentación Solución Experimentemos: str_split(&quot;palabra&quot;, &quot;&quot;)[[1]] #&gt; [1] &quot;p&quot; &quot;a&quot; &quot;l&quot; &quot;a&quot; &quot;b&quot; &quot;r&quot; &quot;a&quot; str_split(&quot;una frase&quot;, &quot;&quot;)[[1]] #&gt; [1] &quot;u&quot; &quot;n&quot; &quot;a&quot; &quot; &quot; &quot;f&quot; &quot;r&quot; &quot;a&quot; &quot;s&quot; &quot;e&quot; Una cadena vacía \"\" divide cada caracter de la cadena. 14.4 Otro tipo de patrones 14.4.1 Ejercicios ¿Cómo buscarías todas las cadenas que contienen \\ con regex() vs. con fixed()? Solución La diferencia se encuentra en la cadena que representa la expresión regular: barras &lt;- &quot;una barra \\\\, dos barras \\\\\\\\, tres barras \\\\\\\\\\\\&quot; writeLines(barras) #&gt; una barra \\, dos barras \\\\, tres barras \\\\\\ str_view_all(barras, regex(&quot;\\\\\\\\&quot;)) str_view_all(barras, fixed(&quot;\\\\&quot;)) ¿Cuáles son las cinco palabras más comunes en oraciones? Solución Para resolver esta pregunta tenemos que extraer cada palabra de forma individual y luego contar su frecuencia. Podemos extraer todas las palabras de forma individual utilizando el código al final de esta sección. Luego, podemos convertir eso en un tibble y contar. No hay que olvidar convertir todas las mayúsculas a minúsculas con str_to_lower str_extract_all(oraciones, boundary(&quot;word&quot;)) %&gt;% unlist() %&gt;% # convertimos la lista en vector tibble(palabra = .) %&gt;% #creamos un tibble count(str_to_lower(palabra)) %&gt;% # contamos top_n(5) # buscamos las cinco más frecuentes #&gt; Selecting by n #&gt; # A tibble: 5 x 2 #&gt; `str_to_lower(palabra)` n #&gt; &lt;chr&gt; &lt;int&gt; #&gt; 1 de 26 #&gt; 2 el 29 #&gt; 3 en 16 #&gt; 4 la 30 #&gt; 5 y 14 Como era de esperar, las palabras más frecuentes son palabras de función como preposiciones, artículos y conjunciones. 14.6 stringi 14.6.1 Ejercicios Busca la función de stringi que: Cuenta el número de palabras. Busca cadenas duplicadas. Genera texto aleatorio. Solución Las funciones que nos sirven en cada uno de estos casos son: stringi::stri_count_words() stringi::stri_duplicated(palabras) stringi::stri_rand_lipsum() ¿Cómo puedes controlar qué lengua usa stri_sort() para ordenar? Solución Podemos controlar la lengua que se utiliza en stri_sort() con el argumento locale. El archivo de ayuda de esta función propone el siguiente ejemplo para ilustrar este comportamiento: stringi::stri_sort(c(&quot;hladny&quot;, &quot;chladny&quot;), locale=&quot;pl_PL&quot;) #&gt; [1] &quot;chladny&quot; &quot;hladny&quot; stringi::stri_sort(c(&quot;hladny&quot;, &quot;chladny&quot;), locale=&quot;sk_SK&quot;) #&gt; [1] &quot;hladny&quot; &quot;chladny&quot; "]
]
