[
["index.html", "R para Ciencia de Datos: Soluciones de los ejercicios Bienvenida", " R para Ciencia de Datos: Soluciones de los ejercicios Riva Quiroga Mauricio ‘Pachá’ Vargas Bienvenida "],
["introduccion.html", "1 Introducción", " 1 Introducción "],
["visualizacion-de-datos.html", "2 Visualización de datos 2.1 Paquetes necesarios 2.2 Primeros pasos 2.3 Mapeos estéticos 2.4 Separar en facetas 2.5 Objetos geométricos 2.6 Transformaciones estadísticas 2.7 Ajustes de posición 2.8 Sistemas de coordenadas", " 2 Visualización de datos 2.1 Paquetes necesarios library(ggplot2) library(datos) 2.2 Primeros pasos 2.2.1 Ejercicios Corre ggplot(data = millas). ¿Qué observas? ¿Cuántas filas hay en millas? ¿Cuántas columnas? ¿Qué describe la variable traccion? Lee la ayuda de ?millas para encontrar la respuesta. Realiza un gráfico de dispersión de autopista versus cilindros. ¿Qué sucede cuando haces un gráfico de dispersión de clase versus traccion? ¿Por qué no es útil este gráfico? 2.3 Mapeos estéticos 2.3.1 Ejercicios ¿Qué no va bien en este código? ¿Por qué hay puntos que no son azules? ggplot(data = millas) + geom_point(mapping = aes(x = motor, y = autopista, color = &quot;blue&quot;)) ¿Qué variables en millas son categóricas? ¿Qué variables son continuas? (Sugerencia: escribe ?millas para leer la documentación de ayuda para este conjunto de datos). ¿Cómo puedes ver esta información cuando ejecutas millas? Asigna una variable continua a color, size, y shape. ¿Cómo se comportan estas estéticas de manera diferente para variables categóricas y variables continuas? ¿Qué ocurre si asignas o mapeas la misma variable a múltiples estéticas? ¿Qué hace la estética stroke? ¿Con qué formas trabaja? (Sugerencia: consultar ?geom_point) ¿Qué ocurre si se asigna o mapea una estética a algo diferente del nombre de una variable, como ser aes(color = motor &lt; 5)? 2.4 Separar en facetas 2.4.1 Ejercicios Qué ocurre si intentas separar en facetas a una variable continua? ¿Qué significan las celdas vacías que aparecen en el gráfico generado usando facet_grid(traccion ~ cilindros)? ¿Cómo se relacionan con este gráfico? ggplot(data = millas) + geom_point(mapping = aes(x = traccion, y = cilindros)) ¿Qué gráfica el siguiente código? ¿Qué hace . ? ggplot(data = millas) + geom_point(mapping = aes(x = motor, y = autopista)) + facet_grid(traccion ~ .) ggplot(data = millas) + geom_point(mapping = aes(x = motor, y = autopista)) + facet_grid(. ~ cilindros) Mira de nuevo el primer gráfico en facetas presentado en esta sección: ggplot(data = millas) + geom_point(mapping = aes(x = motor, y = autopista)) + facet_wrap(~ clase, nrow = 2) ¿Cuáles son las ventajas de separar en facetas en lugar de aplicar una estética de color? ¿Cuáles son las desventajas? ¿Cómo cambiaría este balance si tuvieras un conjunto de datos más grande? Lee ?facet_wrap. ¿Qué hace nrow? ¿Qué hace ncol? ¿Qué otras opciones controlan el diseño de los paneles individuales? ¿Por qué facet_grid() no tiene argumentos nrow y ncol? Cuando usas facet_grid(), generalmente deberías poner la variable con un mayor número de niveles únicos en las columnas. ¿Por qué? 2.5 Objetos geométricos 2.5.1 Ejercicios ¿Qué geom usarías para generar un gráfico de líneas? ¿Un diagrama de caja? ¿Un histograma? ¿Un gráfico de área? Ejecuta este código en tu mente y predice cómo se verá el output. Luego, ejecuta el código en R y verifica tus predicciones. ggplot(data = millas, mapping = aes(x = motor, y = autopista, color = traccion)) + geom_point() + geom_smooth(se = FALSE) ¿Qué muestra show.legend = FALSE? ¿Qué pasa si lo quitas? ¿Por qué crees que lo usé antes en el capítulo? ¿Qué hace el argumento se en geom_smooth()? ¿Se verán distintos estos gráficos? ¿Por qué sí o por qué no? ggplot(data = millas, mapping = aes(x = motor, y = autopista)) + geom_point() + geom_smooth() ggplot() + geom_point(data = millas, mapping = aes(x = motor, y = autopista)) + geom_smooth(data = millas, mapping = aes(x = motor, y = autopista)) Recrea el código R necesario para generar los siguientes gráficos: 2.6 Transformaciones estadísticas 2.6.1 Ejercicios ¿Cuál es el geom predeterminado asociado con stat_summary()? ¿Cómo podrías reescribir el gráfico anterior para usar esa función geom en lugar de la función stat? ¿Qué hace geom_col()? ¿Cómo es diferente a geom_bar()? La mayoría de los geoms y las estadísticas vienen en pares que casi siempre se usan en conjunto. Lee la documentación y has una lista de todos los pares. ¿Qué tienen en común? ¿Qué variables calcula stat_smooth()? ¿Qué parámetros controlan su comportamiento? En nuestro gráfico de barras de proporción , necesitamos establecer group = 1. ¿Por qué? En otras palabras, ¿cuál es el problema con estos dos gráficos? ggplot(data = diamantes) + geom_bar(mapping = aes(x = corte, y = ..prop..)) ggplot(data = diamantes) + geom_bar(mapping = aes(x = corte, fill = color, y = ..prop..)) 2.7 Ajustes de posición 2.7.1 Ejercicios ¿Cuál es el problema con este gráfico? ¿Cómo podrías mejorarlo? ggplot(data = millas, mapping = aes(x = ciudad, y = autopista)) + geom_point() ¿Qué parámetros de geom_jitter() controlan la cantidad de ruido? Compara y contrasta geom_jitter() con geom_count() ¿Cuál es el ajuste de posición predeterminado de geom_boxplot()? Crea una visualización del conjunto de datos de millas que lo demuestre. 2.8 Sistemas de coordenadas 2.8.1 Ejercicios Convierte un gráfico de barras apiladas en un gráfico circular usando coord_polar(). ¿Qué hace labs()? Lee la documentación. ¿Cuál es la diferencia entre coord_quickmap() y coord_map()? ¿Qué te dice la gráfica siguiente sobre la relación entre la ciudad y la autopista? ¿Por qué es coord_fixed() importante? ¿Qué hace geom_abline()? ggplot(data = millas, mapping = aes(x = ciudad, y = autopista)) + geom_point() + geom_abline() + coord_fixed() "],
["flujo-de-trabajo-conocimientos-basicos.html", "3 Flujo de trabajo: conocimientos básicos 3.1 Práctica", " 3 Flujo de trabajo: conocimientos básicos 3.1 Práctica ¿Por qué no funciona este código? mi_variable &lt;- 10 mi_varıable ## Error in eval(expr, envir, enclos): object &#39;mi_varıable&#39; not found ¡Mira detenidamente! (Esto puede parecer un ejercicio inútil, pero entrenar tu cerebro para detectar incluso las diferencias más pequeñas será muy útil cuando comiences a programar.) Modifica cada una de las instrucciones de R a continuación para que puedan ejecutarse correctamente: library(tidyverse) ggplot(data = millas) + geom_point(mapping = aes(x = motor, y = autopista)) fliter(millas, cilindros = 8) filter(diamantes, quilate &gt; 3) Presiona Alt + Shift + K. ¿Qué ocurrió? ¿Cómo puedes llegar al mismo lugar utilizando los menús? "],
["transform.html", "4 Transformación de datos 4.1 Introducción 4.2 Reordenar las filas con arrange() 4.3 Seleccionar columnas con select() 4.4 Añadir nuevas variables con mutate() 4.5 Resúmenes agrupados con summarise() 4.6 Transformaciones agrupadas (y filtros)", " 4 Transformación de datos 4.1 Introducción 4.1.1 Ejercicios Encuentra todos los vuelos que: Tuvieron un retraso de llegada de dos o más horas Volaron a Houston (IAH oHOU) Fueron operados por United, American o Delta Partieron en verano (julio, agosto y septiembre) Llegaron más de dos horas tarde, pero no salieron tarde Se retrasaron por lo menos una hora, pero repusieron más de 30 minutos en vuelo Partieron entre la medianoche y las 6 a.m. (incluyente) Otra función de dplyr útil para usar filtros es between(). ¿Qué hace? ¿Puedes usarlo para simplificar el código necesario para responder a los desafíos anteriores? ¿Cuántos vuelos tienen datos faltantes de horario_salida? ¿Qué otras variables tienen valores faltantes? ¿Qué representan estas filas? ¿Por qué NA ^ 0 no es faltante? ¿Por qué NA | TRUE no es faltante? ¿Por qué FALSE &amp; NA no es faltante? ¿Puedes descubrir la regla general? (¡NA * 0 es un contraejemplo complicado!) 4.2 Reordenar las filas con arrange() 4.2.1 Ejercicios ¿Cómo podrías usar arrange() para ordenar todos los valores faltantes al comienzo? (Sugerencia: usa is.na()). Ordena vuelos para encontrar los vuelos más retrasados. Encuentra los vuelos que salieron más temprano. Ordena vuelos para encontrar los vuelos más rápidos. ¿Cuáles vuelos viajaron más tiempo? ¿Cuál viajó menos tiempo? 4.3 Seleccionar columnas con select() 4.3.1 Ejercicios Haz una lluvia de ideas de tantas maneras como sea posible para seleccionar horario_salida,atraso_salida,horario_llegada, yatraso_llegada de vuelos. ¿Qué sucede si incluyes el nombre de una variable varias veces en una llamada select()? ¿Qué hace la función one_of()? Por qué podría ser útil en conjunto con este vector? vars &lt;- c (&quot;anio&quot;, &quot;mes&quot;, &quot;dia&quot;, &quot;atraso_salida&quot;, &quot;atraso_llegada&quot;) ¿Te sorprende el resultado de ejecutar el siguiente código? ¿Cómo tratan por defecto las funciones auxiliares de select() a las palabras en mayúsculas o en minúsculas? ¿Cómo puedes cambiar ese comportamiento predeterminado? select(vuelos, contains(&quot;SALIDA&quot;)) 4.4 Añadir nuevas variables con mutate() 4.4.1 Ejercicios Las variables horario_salida y salida_programada tienen un formato conveniente para leer, pero es difícil realizar cualquier cálculo con ellas porque no son realmente números continuos. Transfórmalas hacia un formato más conveniente como número de minutos desde la medianoche. Compara tiempo_vuelo con horario_llegada - horario_salida. ¿Qué esperas ver? ¿Qué ves? ¿Qué necesitas hacer para arreglarlo? Compara horario_salida, salida_programada, y atraso_salida. ¿Cómo esperarías que esos tres números estén relacionados? Encuentra los 10 vuelos más retrasados utilizando una función de ordenamiento. ¿Cómo quieres manejar los empates? Lee atentamente la documentación de min_rank(). ¿Qué devuelve 1:3 + 1:10? ¿Por qué? ¿Qué funciones trigonométricas proporciona R? 4.5 Resúmenes agrupados con summarise() 4.5.1 Ejercicios Haz una lluvia de ideas de al menos 5 formas diferentes de evaluar las características de un retraso típico de un grupo de vuelos. Considera los siguientes escenarios: * Un vuelo llega 15 minutos antes 50% del tiempo, y 15 minutos tarde 50% del tiempo. * Un vuelo llega siempre 10 minutos tarde. * Un vuelo llega 30 minutos antes 50% del tiempo, y 30 minutos tarde 50% del tiempo. * Un vuelo llega a tiempo en el 99% de los casos. 1% de las veces llega 2 horas tarde. ¿Qué es más importante: retraso de la llegada o demora de salida? Sugiere un nuevo enfoque que te de el mismo output que no_cancelados %&gt;% count(destino) y no_cancelado %&gt;% count(codigo_cola, wt = distancia) (sin usar count()). Nuestra definición de vuelos cancelados (is.na(atraso_salida) | is.na (atraso_llegada)) es un poco subóptima. ¿Por qué? ¿Cuál es la columna más importante? Mira la cantidad de vuelos cancelados por día. ¿Hay un patrón? ¿La proporción de vuelos cancelados está relacionada con el retraso promedio? ¿Qué compañía tiene los peores retrasos? Desafío: ¿puedes desenredar el efecto de malos aeropuertos vs. el efecto de malas aerolíneas? ¿Por qué o por qué no? (Sugerencia: piensa en vuelos %&gt;% group_by(aerolinea, destino) %&gt;% summarise(n())) ¿Qué hace el argumento sort a count(). ¿Cuándo podrías usarlo? 4.6 Transformaciones agrupadas (y filtros) 4.6.1 Ejercicios Remítete a las listas de funciones útiles de mutación y filtrado. Describe cómo cambia cada operación cuando las combinas con la agrupación. ¿Qué avión (codigo_cola) tiene el peor registro de tiempo? ¿A qué hora del día deberías volar si quieres evitar los retrasos lo más posible? Para cada destino, calcula los minutos totales de demora. Para cada vuelo, calcula la proporción de la demora total para su destino. Los retrasos suelen estar temporalmente correlacionados: incluso una vez que el problema que causó el retraso inicial se ha resuelto, los vuelos posteriores se retrasan para permitir que salgan los vuelos anteriores. Usando lag(), explora cómo el retraso de un vuelo está relacionado con el retraso del vuelo inmediatamente anterior. Mira cada destino. ¿Puedes encontrar vuelos sospechosamente rápidos? (es decir, vuelos que representan un posible error de entrada de datos). Calcula el tiempo en el aire de un vuelo relativo al vuelo más corto a ese destino. ¿Cuáles vuelos se retrasaron más en el aire? Encuentra todos los destinos que son volados por al menos dos operadores. Usa esta información para clasificar a las aerolíneas. Para cada avión, cuenta el número de vuelos antes del primer retraso de más de 1 hora. "],
["flujo-de-trabajo-scripts.html", "5 Flujo de trabajo: Scripts 5.1 Práctica", " 5 Flujo de trabajo: Scripts 5.1 Práctica Visita la cuenta de Twitter de RStudio Tips, https://twitter.com/rstudiotips, y encuentra algún tip que parezca interesante. Practica utilizándolo. ¿Qué otros errores comunes reportarán los diagnósticos de RStudio? Lee https://support.rstudio.com/hc/en-us/articles/205753617-Code-Diagnostics para descubrirlo. "],
["exploratory-data-analysis.html", "6 Exploratory Data Analysis", " 6 Exploratory Data Analysis ¡AGREGAR CUANDO ESTÉ TRADUCIDO! "],
["workflow-projects.html", "7 Workflow: projects", " 7 Workflow: projects ¡AGREGAR CUANDO ESTÉ TRADUCIDO! "],
["tibbles.html", "8 Tibbles 8.1 Ejercicios", " 8 Tibbles library(tibble) 8.1 Ejercicios ¿Cómo puedes saber si un objeto es un tibble? (Sugerencia: imprime mtautos en consola, que es un data frame clásico). Compara y contrasta las siguientes operaciones aplicadas a un data.frame y a un tibble equivalente. ¿Qué es diferente? ¿Por qué podría causarte problemas el comportamiento por defecto del data frame? df &lt;- data.frame(abc = 1, xyz = &quot;a&quot;) df$x df[, &quot;xyz&quot;] df[, c(&quot;abc&quot;, &quot;xyz&quot;)] Si tienes el nombre de una variable guardada en un objeto, p.e., var &lt;- &quot;mpg&quot;, ¿cómo puedes extraer esta variable de un tibble? Practica referenciar nombres no sintácticos en el siguiente data frame: Extrayendo la variable llamada 1. Generando un gráfico de dispersión de 1 vs 2. Creando una nueva columna llamada 3 que sea el resultado de la división de 2 por 1. Renombrando las columnas como uno, dos y tres. molesto &lt;- tibble( `1` = 1:10, `2` = `1` * 2 + rnorm(length(`1`)) ) ¿Qué hace tibble::enframe()? ¿Cuándo lo usarías? ¿Qué opción controla cuántos nombres de columnas adicionales se muestran al pie de un tibble? "],
["importacion-de-datos.html", "9 Importación de datos 9.1 Introducción 9.2 Comenzando 9.3 Analizando un vector", " 9 Importación de datos 9.1 Introducción Trabajar con datos provistos por los paquetes de R es una muy buena forma de conocer las herramientas de la ciencia de datos, pero en cierto punto debes dejar de aprender y comenzar a trabajar con tus propios datos. En este capítulo aprenderás cómo leer archivos rectangulares de texto plano en R. Aquí solo tocaremos superficialmente el tema de importación de datos, pero muchos de los principios se traducen a otras formas de datos. Finalizaremos sugiriendo algunos paquetes que son útiles para otros tipos de datos. 9.1.1 Prerrequisitos En este capítulo aprenderás cómo cargar archivos planos en R con el paquete readr, uno de los paquetes principales de tidyverse. library(tidyverse) 9.2 Comenzando 9.2.1 Ejercicios ¿Qué función utilizarías para leer un archivo donde los campos están separados con “|”? Además de file, skip y comment ¿Qué otros argumentos tienen en común read_csv() y read_tsv()? ¿Cuáles son los argumentos más importantes de read_fwf()? Algunas veces, las cadenas de caracteres en un archivo csv contienen comas. Para evitar que causen problemas deben estar rodeadas por comillas, como &quot; o '. Por convención, read_csv() asume que el caracter de separación será &quot;, y si quieres cambiarlo necesitarás usar read_delim() en su lugar.¿Qué argumentos debes especificar para leer el siguiente texto en un marco de datos? &quot;x,y\\n1,&#39;a,b&#39;&quot; Identifica qué está mal en cada una de los siguientes archivos csv alineados. ¿Qué pasa cuando corres el código? read_csv(&quot;a,b\\n1,2,3\\n4,5,6&quot;) read_csv(&quot;a,b,c\\n1,2\\n1,2,3,4&quot;) read_csv(&quot;a,b\\n\\&quot;1&quot;) read_csv(&quot;a,b\\n1,2\\na,b&quot;) read_csv(&quot;a;b\\n1;3&quot;) 9.3 Analizando un vector 9.3.1 Ejercicios ¿Cuáles son los argumentos más importantes para locale()? ¿Qué pasa si pruebas y estableces decimal_mark y grouping_mark al mismo caracter? ¿Qué pasa con el valor por defecto de grouping_mark cuando seleccionas decimal_mark a ,? ¿Qué pasa con el valor por defecto de decimal_mark cuando estableces grouping_mark a .? No discutí las opciones date_format y time_format para locale(). ¿Qué hacen? Construye un ejemplo que muestre cuándo pueden ser útiles. Si vives fuera de EEUU, crea un nuevo objeto locale que encapsule las opciones para los tipos de archivo que lees más comúnmente. ¿Cuál es la diferencia entre read_csv() y read_csv2()? ¿Cuáles son las codificaciones más comunes empleadas en Europa? ¿Cuáles son las codificaciones más comunes utilizadas en Asia? Googlea un poco para descubrirlo. Genera el formato correcto de texto para analizar cada una de las siguientes fechas y horas: d1 &lt;- &quot;January 1, 2010&quot; d2 &lt;- &quot;2015-Mar-07&quot; d3 &lt;- &quot;06-Jun-2017&quot; d4 &lt;- c(&quot;August 19 (2015)&quot;, &quot;July 1 (2015)&quot;) d5 &lt;- &quot;12/30/14&quot; # Dec 30, 2014 t1 &lt;- &quot;1705&quot; t2 &lt;- &quot;11:15:10.12 PM&quot; "],
["datos-ordenados.html", "10 Datos ordenados 10.1 Datos ordenados 10.2 Reunir y Esparcir 10.3 Separar y unir 10.4 Valores faltantes 10.5 Estudio de caso 10.6 Datos no ordenados", " 10 Datos ordenados library(tibble) 10.1 Datos ordenados 10.1.1 Ejercicios Usando prosa, describe como las variables y observaciones se organizan en las tablas de ejemplo. Calcula la tasa para las tablas tabla2 y tabla4a + tabla4b. Necesitarás las siguientes operaciones: Extrae el número de casos de tuberculosis por país y año. Extrae la población por país y año. Divide los casos por la población y multiplica por 10000. Inserta los datos en el lugar adecuado. ¿Cuál representación es más fácil de trabajar? ¿Cuál es la más difícil? ¿Por qué? Recrea el gráfico que muestra el cambio en el número de casos usando la tabla2 en lugar de la tabla1. ¿Qué debes hacer en primer lugar? 10.2 Reunir y Esparcir 10.2.1 Ejercicios ¿Por qué gather() y spread() no son perfectamente simétricas? Observa cuidadosamente el siguiente ejemplo: acciones &lt;- tibble( anio = c(2015, 2015, 2016, 2016), semestre = c(1, 2, 1, 2), retorno = c(1.88, 0.59, 0.92, 0.17) ) acciones %&gt;% spread(anio, retorno) %&gt;% gather(&quot;anio&quot;, &quot;retorno&quot;, `2015`:`2016`) (Pista: observa los tipos de variables y piensa en los nombres de las columnas) Tanto spread() como gather() tienen el argumento convert (convertir). ¿Qué hace dicho argumento? ¿Por qué falla el siguiente código? tabla4a %&gt;% gather(`1999`, `2000`, key = &quot;anio&quot;, value = &quot;casos&quot;) ## Error in tabla4a %&gt;% gather(`1999`, `2000`, key = &quot;anio&quot;, value = &quot;casos&quot;): could not find function &quot;%&gt;%&quot; ¿Por qué no se puede extender la siguiente tabla? ¿Cómo agregarias una nueva columna para resolver el problema? personas &lt;- tribble( ~nombre, ~clave, ~valor, #-----------------|--------|------ &quot;Phillip Woods&quot;, &quot;edad&quot;, 45, &quot;Phillip Woods&quot;, &quot;estatura&quot;, 186, &quot;Phillip Woods&quot;, &quot;edad&quot;, 50, &quot;Jessica Cordero&quot;, &quot;edad&quot;, 37, &quot;Jessica Cordero&quot;, &quot;estatura&quot;, 156 ) Ordena la siguiente tabla. ¿Necesitas extenderla o contraerla? ¿Cuáles son las variables? embarazo &lt;- tribble( ~embarazo, ~hombre, ~mujer, &quot;sí&quot;, NA, 10, &quot;no&quot;, 20, 12 ) 10.3 Separar y unir 10.3.1 Ejercicios ¿Qué hacen los argumentos extra y fill en separate()? Experimenta con las diversas opciones a partir de los siguientes datasets de ejemplo. tibble(x = c(&quot;a,b,c&quot;, &quot;d,e,f,g&quot;, &quot;h,i,j&quot;)) %&gt;% separate(x, c(&quot;one&quot;, &quot;two&quot;, &quot;three&quot;)) tibble(x = c(&quot;a,b,c&quot;, &quot;d,e&quot;, &quot;f,g,i&quot;)) %&gt;% separate(x, c(&quot;one&quot;, &quot;two&quot;, &quot;three&quot;)) Tanto unite() como separate() tienen un argumento remove. ¿Qué es lo que hace? ¿Por qué lo dejarías en FALSE? Compara y contrasta separate() y extract(). ¿Por qué existen tres variaciones de separación (por posición, separador y grupos), pero solo una forma de unir? 10.4 Valores faltantes 10.4.1 Ejercicios Compara y contrasta el argumento fill que se usa en spread() con complete(). ¿Qué hace el argumento de dirección en fill()? 10.5 Estudio de caso 10.5.1 Ejercicios En este caso de estudio fijamos na.rm = TRUE para simplificar la verificación de que tenemos los valores correctos. ¿Es esto razonable? Piensa en como los valores faltantes están representados en este dataset. ¿Existen valores faltantes implícitos? ¿Cuál es la diferencia entre NA y cero? ¿Qué ocurre si omites la aplicación de mutate()? (mutate(llave = stringr::str_replace(llave, &quot;nuevosrecaida&quot;, &quot;nuevos_recaida&quot;))) Afirmamos que iso2 e iso3 son redundantes respecto a pais. Confirma esta premisa. Para cada país, año y sexo calcula el total del número de casos de tuberculosis. Crea una visualización informativa de los datos. 10.6 Datos no ordenados Antes de pasar a otros tópicos, es conveniente referirse brevemente a datos no ordenados. Anteriormente en el capítulo, usamos el término peyorativo “desordenados” para referirnos a datos no ordenados. Esto es una sobresimplificación: existen múltiples estructuras de datos debidamente fundamentadas que no corresponden a datos ordenados. Existen dos principales razones para usar otras estructuras de datos: Las representaciones alternativas pueden traer ventajas importantes en términos de desempeño o tamaño. Algunos áreas especializadas han evolucionado y tienen sus propias convenciones para almacenar datos, las que pueden diferir respecto de las convenciones de datos ordenados. Cada uno de estas razones significa que necesitarás algo distinto a un tibble (o data frame). Si tus datos naturalmente se ajustan a una estructura rectangular compuesta de observaciones y variables, pensamos que datos ordenados debería ser tu elección por defecto. Sin embargo, existen buenas razones para usar otras estructuras; datos ordenados no es la única forma. Si quieres aprender más acerca de datos no ordenados, recomendamos fuertemente este artículo del blog de Jeff Leek: http://simplystatistics.org/2016/02/17/non-tidy-data/ "],
["datos-relacionales.html", "11 Datos relacionales 11.1 Paquetes necesarios 11.2 datos 11.3 Llaves 11.4 Uniones de transformación 11.5 Uniones de filtro 11.6 Problemas de las uniones", " 11 Datos relacionales 11.1 Paquetes necesarios library(dplyr) library(ggplot2) library(datos) 11.2 datos 11.2.1 Ejercicios Imagina que necesitas dibujar (aproximadamente) la ruta que cada avión vuela desde su origen hasta el destino. ¿Qué variables necesitas? ¿Qué tablas necesitas combinar? Solución Necesitas combinar aeropuertos con vuelos ya que el dataset aeropuertos con tiene las coordenadas de los aeropuertos. Puedes unir las tablas por medio de la variable codigo_aeropuerto en aeropuertos y origen y destino en vuelos. vuelos %&gt;% left_join(aeropuertos, by = c(&quot;origen&quot; = &quot;codigo_aeropuerto&quot;, &quot;destino&quot; = &quot;codigo_aeropuerto&quot;)) ## # A tibble: 336,776 x 26 ## anio mes dia horario_salida salida_programa… atraso_salida ## &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;dbl&gt; ## 1 2013 1 1 517 515 2 ## 2 2013 1 1 533 529 4 ## 3 2013 1 1 542 540 2 ## 4 2013 1 1 544 545 -1 ## 5 2013 1 1 554 600 -6 ## 6 2013 1 1 554 558 -4 ## 7 2013 1 1 555 600 -5 ## 8 2013 1 1 557 600 -3 ## 9 2013 1 1 557 600 -3 ## 10 2013 1 1 558 600 -2 ## # … with 336,766 more rows, and 20 more variables: horario_llegada &lt;int&gt;, ## # llegada_programada &lt;int&gt;, atraso_llegada &lt;dbl&gt;, aerolinea &lt;chr&gt;, ## # vuelo &lt;int&gt;, codigo_cola &lt;chr&gt;, origen &lt;chr&gt;, destino &lt;chr&gt;, ## # tiempo_vuelo &lt;dbl&gt;, distancia &lt;dbl&gt;, hora &lt;dbl&gt;, minuto &lt;dbl&gt;, ## # fecha_hora &lt;dttm&gt;, nombre &lt;chr&gt;, latitud &lt;dbl&gt;, longitud &lt;dbl&gt;, ## # altura &lt;int&gt;, zona_horaria &lt;dbl&gt;, horario_verano &lt;chr&gt;, ## # zona_horaria_iana &lt;chr&gt; Olvidamos incluir la relación entre clima y aeropuertos. ¿Cuál es la relación y cómo debe aparecer en el diagrama? Solución De manera similar al ejercicio anterior, se pueden unir mediante codigo_aeropuerto en aeropuertos y origen en clima. clima únicamente contiene información de los aeropuertos de origen (Nueva York). Si contuviera registros para todos los aeropuertos de EEUU, ¿Qué relación tendría con vuelos? Solución Puedes conectar clima con vuelos usando la columna destino e incluir el clima de los aeropuertos de EEUU que están presentes en la tabla vuelos. Sabemos que hay días “especiales” en el año y pocas personas vuelan esos días. ¿Cómo se representarían en un data frame? ¿Cuáles serían las llaves primarias de esa tabla? ¿Cómo se conectaría con las tablas existentes? Solución Una posibilidad es contar con un dataset de los días festivos en EEUU indicando mes y día. Esta información se puede unir con cada vuelo en la tabla vuelos y y a la vez con el dataset clima. 11.3 Llaves 11.3.1 Ejercicios Agrega una llave sustituta a vuelos. Solución vuelos %&gt;% mutate(id = row_number(anio)) %&gt;% select(id, everything()) ## # A tibble: 336,776 x 20 ## id anio mes dia horario_salida salida_programa… atraso_salida ## &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;dbl&gt; ## 1 1 2013 1 1 517 515 2 ## 2 2 2013 1 1 533 529 4 ## 3 3 2013 1 1 542 540 2 ## 4 4 2013 1 1 544 545 -1 ## 5 5 2013 1 1 554 600 -6 ## 6 6 2013 1 1 554 558 -4 ## 7 7 2013 1 1 555 600 -5 ## 8 8 2013 1 1 557 600 -3 ## 9 9 2013 1 1 557 600 -3 ## 10 10 2013 1 1 558 600 -2 ## # … with 336,766 more rows, and 13 more variables: horario_llegada &lt;int&gt;, ## # llegada_programada &lt;int&gt;, atraso_llegada &lt;dbl&gt;, aerolinea &lt;chr&gt;, ## # vuelo &lt;int&gt;, codigo_cola &lt;chr&gt;, origen &lt;chr&gt;, destino &lt;chr&gt;, ## # tiempo_vuelo &lt;dbl&gt;, distancia &lt;dbl&gt;, hora &lt;dbl&gt;, minuto &lt;dbl&gt;, ## # fecha_hora &lt;dttm&gt; Identifica las llaves en los siguientes conjuntos de datos datos::bateadores datos::nombres datos::atmosfera datos::vehiculos datos::diamantes (Puede que necesites leer un poco de documentación.) Solución En datos::bateadores corresponde a id_jugador. En datos::nombres corresponde a la combinación de anio y nombre, con esto se puede unir cada par año-nombre con las otras tablas. En datos::atmosfera corresponde a latitud,longitud,anioymes`, lo cual identifica de manera única un lugar en el tiempo. En datos::vehiculos corresponde a id. En datos::diamantes no hay llaves ya que estas tienen sentido en datos relacionales, es decir cuando existen otras tablas para combinar información. Dibuja un diagrama que ilustre las conexiones entre las tablas bateadores, personas y salarios en el paquete datos. Dibuja otro diagrama que muestre la relación entre personas, dirigentes y premios_dirigentes. ¿Cómo caracterizarías las relación entre bateadores, lanzadores y fildeo? Solución Es directo. Las tres tablas contienen los campos id_jugador y anio y cada tabla contiene información que complementa las demás. La relación es uno a uno. 11.4 Uniones de transformación 11.4.1 Ejercicios Calcula el atraso promedio por destino, luego une los datos en aeropuertos para que puedas mostrar la distribución espacial de los atrasos. Te presentamos una forma fácil de dibujar un mapa de los Estados Unidos: aeropuertos %&gt;% semi_join(vuelos, c(&quot;codigo_aeropuerto&quot; = &quot;destino&quot;)) %&gt;% ggplot(aes(longitud, latitud)) + borders(&quot;state&quot;) + geom_point() + coord_quickmap() (No te preocupes si no entiendes que hace semi_join(). Lo aprenderás a continuación.) Quizás quieras usar size o colour para editar los puntos y mostrar el atraso promedio de cada aeropuerto. Solución atraso_promedio_destino &lt;- vuelos %&gt;% group_by(destino) %&gt;% # los vuelos con NA en atraso_llegada son vuelos cancelados summarise(atraso = mean(atraso_llegada, na.rm = TRUE)) %&gt;% inner_join(aeropuertos, by = c(destino = &quot;codigo_aeropuerto&quot;)) atraso_promedio_destino %&gt;% ggplot(aes(longitud, latitud, colour = atraso)) + borders(&quot;state&quot;) + geom_point() + coord_quickmap() Agrega la ubicación de origen y destino (e.g. latitud y longitud) a vuelos. Solución Es posible realizar varias uniones. Si hay variables duplicadas, dplyr va a distinguirlas agregando .x y .y al nombre de la variable para resolver los nombres duplicados. ubicacion_aeropuertos &lt;- aeropuertos %&gt;% select(codigo_aeropuerto, latitud, longitud) vuelos %&gt;% select(anio:dia, hora, origen, destino) %&gt;% left_join( ubicacion_aeropuertos, by = c(&quot;origen&quot; = &quot;codigo_aeropuerto&quot;) ) %&gt;% left_join( ubicacion_aeropuertos, by = c(&quot;destino&quot; = &quot;codigo_aeropuerto&quot;) ) ## # A tibble: 336,776 x 10 ## anio mes dia hora origen destino latitud.x longitud.x latitud.y ## &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 2013 1 1 5 EWR IAH 40.7 -74.2 30.0 ## 2 2013 1 1 5 LGA IAH 40.8 -73.9 30.0 ## 3 2013 1 1 5 JFK MIA 40.6 -73.8 25.8 ## 4 2013 1 1 5 JFK BQN 40.6 -73.8 NA ## 5 2013 1 1 6 LGA ATL 40.8 -73.9 33.6 ## 6 2013 1 1 5 EWR ORD 40.7 -74.2 42.0 ## 7 2013 1 1 6 EWR FLL 40.7 -74.2 26.1 ## 8 2013 1 1 6 LGA IAD 40.8 -73.9 38.9 ## 9 2013 1 1 6 JFK MCO 40.6 -73.8 28.4 ## 10 2013 1 1 6 LGA ORD 40.8 -73.9 42.0 ## # … with 336,766 more rows, and 1 more variable: longitud.y &lt;dbl&gt; Es una buena práctica tener nombres indicativos para las variables. Usaremos el sufijo _destino y _origen para especificar a qué aeropuerto nos referimos. vuelos %&gt;% select(anio:dia, hora, origen, destino) %&gt;% left_join( ubicacion_aeropuertos, by = c(&quot;origen&quot; = &quot;codigo_aeropuerto&quot;) ) %&gt;% left_join( ubicacion_aeropuertos, by = c(&quot;destino&quot; = &quot;codigo_aeropuerto&quot;), suffix = c(&quot;_origen&quot;, &quot;_destino&quot;) ) ## # A tibble: 336,776 x 10 ## anio mes dia hora origen destino latitud_origen longitud_origen ## &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 2013 1 1 5 EWR IAH 40.7 -74.2 ## 2 2013 1 1 5 LGA IAH 40.8 -73.9 ## 3 2013 1 1 5 JFK MIA 40.6 -73.8 ## 4 2013 1 1 5 JFK BQN 40.6 -73.8 ## 5 2013 1 1 6 LGA ATL 40.8 -73.9 ## 6 2013 1 1 5 EWR ORD 40.7 -74.2 ## 7 2013 1 1 6 EWR FLL 40.7 -74.2 ## 8 2013 1 1 6 LGA IAD 40.8 -73.9 ## 9 2013 1 1 6 JFK MCO 40.6 -73.8 ## 10 2013 1 1 6 LGA ORD 40.8 -73.9 ## # … with 336,766 more rows, and 2 more variables: latitud_destino &lt;dbl&gt;, ## # longitud_destino &lt;dbl&gt; ¿Existe una relación entre la antiguedad de un avión y sus atrasos? Solución Ya que no se indica si se refiere a atrasos de salida o llegada, se explorará el atraso en la salida, quedando el otro caso como ejercicio. Para comparar la antiguedad de un avión con sus atrasos, hay que unir vuelos con aviones, esta última tabla contiene la variable anio que se refiere al año de fabricación del avión. Dado que hay pocos aviones de más de 25 años, truncaremos los datos y luego vamos a calcular el promedio de llegada y salida dada la antiguedad. atrasos_por_antiguedad &lt;- inner_join(vuelos, select(aviones, codigo_cola, anio_fabricacion = anio), by = &quot;codigo_cola&quot;) %&gt;% mutate(antiguedad = anio - anio_fabricacion) %&gt;% filter(!is.na(antiguedad)) %&gt;% mutate(antiguedad = if_else(antiguedad &gt; 25, 25L, antiguedad)) %&gt;% group_by(antiguedad) %&gt;% summarise( prom_atraso_salida = mean(atraso_salida, na.rm = TRUE), desv_est_atraso_salida = sd(atraso_salida, na.rm = TRUE), nro_vuelos_atrasados_salida = sum(!is.na(atraso_salida)) ) Ahora podemos explorar la reglación entre los atrasos en la salida y la antiguedad. El atraso en la salida es creciente en relación a la antiguedad para los aviones de hasta de 10 años. Luego este atraso decae. La reducción de los atrasos en la salida en relación a la antiguedad puede deberse a que en los aviones más antiguos se planfica la mantención para evitar tales atrasos y desperfectos mecánicos. ggplot(atrasos_por_antiguedad, aes(x = antiguedad, y = prom_atraso_salida)) + geom_point() + scale_x_continuous(&quot;Antiguedad del avión (años)&quot;, breaks = seq(0, 30, by = 10)) + scale_y_continuous(&quot;Atraso promedio en la salida (minutos)&quot;) ¿Qué condiciones climáticas hacen más probables los atrasos? Solución Las lluvias están asociadas con los atrasos. Sin embargo, para un nivel mayor a 0.02 pulgadas de lluvia no hay una tendencia fuerte. vuelo_clima &lt;- vuelos %&gt;% inner_join(clima, by = c( &quot;origen&quot;, &quot;anio&quot;, &quot;mes&quot;, &quot;dia&quot;, &quot;hora&quot; )) vuelo_clima %&gt;% group_by(precipitacion) %&gt;% summarise(atraso = mean(atraso_salida, na.rm = TRUE)) %&gt;% ggplot(aes(x = precipitacion, y = atraso)) + geom_line() + geom_point() ¿Qué sucedió el día 13 de junio de 2013? Muestra el patrón espacial de los atrasos, luego usa un buscador para encontrar referencias cruzadas con el clima. Solución Hubo una serie de tormentas en el sureste de los EEUU (consulta la Wikipedia). El siguiente gráfico muestra que los mayores atrasos se presentaron en Tennessee (Nashville), el sureste y medio oeste es donde ocurrieron las tormentas. vuelos %&gt;% filter(anio == 2013, mes == 6, dia == 13) %&gt;% group_by(destino) %&gt;% summarise(atraso = mean(atraso_salida, na.rm = TRUE)) %&gt;% inner_join(aeropuertos, by = c(&quot;destino&quot; = &quot;codigo_aeropuerto&quot;)) %&gt;% ggplot(aes(y = latitud, x = longitud, size = atraso, colour = atraso)) + borders(&quot;state&quot;) + geom_point() + coord_quickmap() + scale_colour_viridis_c() ## Warning: Removed 3 rows containing missing values (geom_point). 11.5 Uniones de filtro 11.5.1 Ejercicios ¿Qué significa que un vuelo no tenga codigo_cola? ¿Qué tienen en común los códigos de cola que no tienen registros coincidentes en aviones? (Pista: Una variable explica ~90% de los problemas.) Solución Los vuelos que no registran código cola tampoco registran hora de llegada, por lo que son vuelos cancelados. vuelos %&gt;% filter(is.na(codigo_cola), !is.na(horario_llegada)) %&gt;% nrow() ## [1] 0 Muchos de los vuelos sin código cola en aviones pertenecen a American Airlines (AA) o Envoy Airlines (EQ) como se detalla en la documentación. vuelos %&gt;% anti_join(aviones, by = &quot;codigo_cola&quot;) %&gt;% count(aerolinea, sort = TRUE) %&gt;% mutate(p = n / sum(n)) ## # A tibble: 10 x 3 ## aerolinea n p ## &lt;chr&gt; &lt;int&gt; &lt;dbl&gt; ## 1 MQ 25397 0.483 ## 2 AA 22558 0.429 ## 3 UA 1693 0.0322 ## 4 9E 1044 0.0198 ## 5 B6 830 0.0158 ## 6 US 699 0.0133 ## 7 FL 187 0.00355 ## 8 DL 110 0.00209 ## 9 F9 50 0.000950 ## 10 WN 38 0.000722 Sin embargo, no todos los códigos que aparecen en vuelos están perdidos en aviones. vuelos %&gt;% distinct(aerolinea, codigo_cola) %&gt;% left_join(aviones, by = &quot;codigo_cola&quot;) %&gt;% group_by(aerolinea) %&gt;% summarise(total_aviones = n(), faltan_en_aviones = sum(is.na(modelo))) %&gt;% mutate(porcentaje_perdidos = faltan_en_aviones / total_aviones) %&gt;% arrange(desc(porcentaje_perdidos)) ## # A tibble: 16 x 4 ## aerolinea total_aviones faltan_en_aviones porcentaje_perdidos ## &lt;chr&gt; &lt;int&gt; &lt;int&gt; &lt;dbl&gt; ## 1 MQ 238 234 0.983 ## 2 AA 601 430 0.715 ## 3 F9 26 3 0.115 ## 4 FL 129 12 0.0930 ## 5 UA 621 23 0.0370 ## 6 US 290 9 0.0310 ## 7 DL 629 10 0.0159 ## 8 B6 193 3 0.0155 ## 9 WN 583 3 0.00515 ## 10 9E 204 1 0.00490 ## 11 AS 84 0 0 ## 12 EV 316 0 0 ## 13 HA 14 0 0 ## 14 OO 28 0 0 ## 15 VX 53 0 0 ## 16 YV 58 0 0 Filtra los vuelos para mostrar únicamente los aviones que han realizado al menos cien viajes. Solución Debemos calcular que aviones tienen 100 o más vuelos. Hay que filtrar los aviones sin código cola o estos se van a considerar como un único avión. cien_vuelos &lt;- vuelos %&gt;% filter(!is.na(codigo_cola)) %&gt;% group_by(codigo_cola) %&gt;% count() %&gt;% filter(n &gt;= 100) Ahora se puede unir el resultado con la tabla vuelos y así conservar los que cumplen con el criterio. vuelos %&gt;% semi_join(cien_vuelos, by = &quot;codigo_cola&quot;) ## # A tibble: 228,390 x 19 ## anio mes dia horario_salida salida_programa… atraso_salida ## &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;dbl&gt; ## 1 2013 1 1 517 515 2 ## 2 2013 1 1 533 529 4 ## 3 2013 1 1 544 545 -1 ## 4 2013 1 1 554 558 -4 ## 5 2013 1 1 555 600 -5 ## 6 2013 1 1 557 600 -3 ## 7 2013 1 1 557 600 -3 ## 8 2013 1 1 558 600 -2 ## 9 2013 1 1 558 600 -2 ## 10 2013 1 1 558 600 -2 ## # … with 228,380 more rows, and 13 more variables: horario_llegada &lt;int&gt;, ## # llegada_programada &lt;int&gt;, atraso_llegada &lt;dbl&gt;, aerolinea &lt;chr&gt;, ## # vuelo &lt;int&gt;, codigo_cola &lt;chr&gt;, origen &lt;chr&gt;, destino &lt;chr&gt;, ## # tiempo_vuelo &lt;dbl&gt;, distancia &lt;dbl&gt;, hora &lt;dbl&gt;, minuto &lt;dbl&gt;, ## # fecha_hora &lt;dttm&gt; Otra posibilidad es agrupar y luego usar mutate(). vuelos %&gt;% filter(!is.na(codigo_cola)) %&gt;% group_by(codigo_cola) %&gt;% mutate(n = n()) %&gt;% filter(n &gt;= 100) ## # A tibble: 228,390 x 20 ## # Groups: codigo_cola [1,217] ## anio mes dia horario_salida salida_programa… atraso_salida ## &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;dbl&gt; ## 1 2013 1 1 517 515 2 ## 2 2013 1 1 533 529 4 ## 3 2013 1 1 544 545 -1 ## 4 2013 1 1 554 558 -4 ## 5 2013 1 1 555 600 -5 ## 6 2013 1 1 557 600 -3 ## 7 2013 1 1 557 600 -3 ## 8 2013 1 1 558 600 -2 ## 9 2013 1 1 558 600 -2 ## 10 2013 1 1 558 600 -2 ## # … with 228,380 more rows, and 14 more variables: horario_llegada &lt;int&gt;, ## # llegada_programada &lt;int&gt;, atraso_llegada &lt;dbl&gt;, aerolinea &lt;chr&gt;, ## # vuelo &lt;int&gt;, codigo_cola &lt;chr&gt;, origen &lt;chr&gt;, destino &lt;chr&gt;, ## # tiempo_vuelo &lt;dbl&gt;, distancia &lt;dbl&gt;, hora &lt;dbl&gt;, minuto &lt;dbl&gt;, ## # fecha_hora &lt;dttm&gt;, n &lt;int&gt; Combina vehiculos y comunes para encontrar los registros de los modelos más comunes. Solución Debemos unir por fabricante y modelo, a modo de evitar hacer un match incorrecto debido a que dos fabricantes tengan un vehículo con el mismo nombre. vehiculos %&gt;% semi_join(comunes, by = c(&quot;fabricante&quot;, &quot;modelo&quot;)) ## # A tibble: 14,531 x 12 ## id fabricante modelo anio clase transmision traccion cilindros motor ## &lt;int&gt; &lt;chr&gt; &lt;chr&gt; &lt;int&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;int&gt; &lt;dbl&gt; ## 1 1833 Acura Integ… 1986 Auto… Automática… Delante… 4 1.6 ## 2 1834 Acura Integ… 1986 Auto… Manual 5-v… Delante… 4 1.6 ## 3 3037 Acura Integ… 1987 Auto… Automática… Delante… 4 1.6 ## 4 3038 Acura Integ… 1987 Auto… Manual 5-v… Delante… 4 1.6 ## 5 4183 Acura Integ… 1988 Auto… Automática… Delante… 4 1.6 ## 6 4184 Acura Integ… 1988 Auto… Manual 5-v… Delante… 4 1.6 ## 7 5303 Acura Integ… 1989 Auto… Automática… Delante… 4 1.6 ## 8 5304 Acura Integ… 1989 Auto… Manual 5-v… Delante… 4 1.6 ## 9 6442 Acura Integ… 1990 Auto… Automática… Delante… 4 1.8 ## 10 6443 Acura Integ… 1990 Auto… Manual 5-v… Delante… 4 1.8 ## # … with 14,521 more rows, and 3 more variables: combustible &lt;chr&gt;, ## # autopista &lt;int&gt;, ciudad &lt;int&gt; Encuentra las 48 horas (en el transcurso del año) que tengan los peores atrasos. Haz una referencia cruzada con la tabla clima. ¿Puedes observar patrones? Solución Haremos el desarrollo considerando las horas con mayor acumulación de atrasos en la salida. El otro caso queda como ejercicio. El ejercicio no pide que sean los dos peores días, sino las peores 48 horas, por lo que debemos tomar las peores horas en el transcurso de varios días. peores_horas &lt;- vuelos %&gt;% mutate(hora = salida_programada %/% 100) %&gt;% group_by(origen, anio, mes, dia, hora) %&gt;% summarise(atraso_salida = mean(atraso_salida, na.rm = TRUE)) %&gt;% ungroup() %&gt;% arrange(desc(atraso_salida)) %&gt;% slice(1:48) Este resultado se debe unir con la tabla clima. clima_peores_horas &lt;- semi_join(clima, peores_horas, by = c(&quot;origen&quot;, &quot;anio&quot;, &quot;mes&quot;, &quot;dia&quot;, &quot;hora&quot;)) Para el clima, nos enfocaremos en la precipitación, velocidad del viento y temperatura. Muchas de estas observaciones tienen una velocidad del viento por sobre el promedio (10 millas por hora) o lluvias. select(clima_peores_horas, temperatura, velocidad_viento, precipitacion) %&gt;% print(n = 48) ## # A tibble: 48 x 3 ## temperatura velocidad_viento precipitacion ## &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 27.0 13.8 0 ## 2 28.0 19.6 0 ## 3 28.9 28.8 0 ## 4 33.8 9.21 0.06 ## 5 34.0 8.06 0.05 ## 6 80.1 8.06 0 ## 7 86 13.8 0 ## 8 73.4 6.90 0.08 ## 9 84.0 5.75 0 ## 10 78.8 18.4 0.23 ## 11 53.6 0 0 ## 12 60.8 31.1 0.11 ## 13 55.4 17.3 0.14 ## 14 53.1 9.21 0.01 ## 15 55.9 11.5 0.1 ## 16 55.4 8.06 0.15 ## 17 57.0 29.9 0 ## 18 33.8 20.7 0.02 ## 19 34.0 19.6 0.01 ## 20 36.0 21.9 0.01 ## 21 37.9 16.1 0 ## 22 32 13.8 0.12 ## 23 60.1 33.4 0.14 ## 24 60.8 11.5 0.02 ## 25 62.1 17.3 0 ## 26 66.9 10.4 0 ## 27 66.9 13.8 0 ## 28 79.0 10.4 0 ## 29 77 16.1 0.07 ## 30 75.9 13.8 0 ## 31 82.4 8.06 0 ## 32 86 9.21 0 ## 33 80.1 9.21 0 ## 34 80.6 11.5 0 ## 35 78.1 6.90 0 ## 36 75.2 10.4 0.01 ## 37 73.9 5.75 0.03 ## 38 73.9 8.06 0 ## 39 75.0 4.60 0 ## 40 75.0 4.60 0.01 ## 41 80.1 0 0.01 ## 42 80.1 0 0 ## 43 77 10.4 0 ## 44 82.0 10.4 0 ## 45 72.0 13.8 0.3 ## 46 72.0 4.60 0.03 ## 47 51.1 4.60 0 ## 48 54.0 6.90 0 ggplot(clima_peores_horas, aes(x = precipitacion, y = velocidad_viento, color = temperatura)) + geom_point() Para extenderse con mayor detalle en ese ejercicio, es necesario usar las herramientas del capítulo Análisis Exploratorio de Datos. ¿Qué te indica anti_join(vuelos, aeropuertos, by = c(&quot;destino&quot; = &quot;codigo_aeropuerto&quot;))? ¿Qué te indica anti_join(aeropuertos, vuelos, by = c(&quot;codigo_aeropuerto&quot; = &quot;destino&quot;))? Solución La primera expresión entrega los vuelos cuyo destino es un aeropuerto fuera de los EEUU. La segunda expresión entrega lo aeropuertos de los EEUU que no son el destino de los vuelos contenidos en los datos. Los datos contienen todos los vuelos de los aeropuertos de Nueva York, por lo que también contiene los vuelos con escalas intermedias. Puedes esperar que exista una relación implícita entre aviones y aerolíneas, dado que cada avión es operado por una única aerolínea. Confirma o descarta esta hipótesis usando las herramientas que aprendiste más arriba. Solución At each point in time, each plane is flown by a single airline. However, a plane can be sold and fly for multiple airlines. Logically, it is possible that a plane can fly for multiple airlines over the course of its lifetime. But, it is not necessarily the case that a plane will fly for more than one airline in this data, especially since it comprises only a year of data. So let’s check to see if there are any planes in the data flew for multiple airlines. Veámos las combinaciones únicas de aerolíneay avión. aerolinea_avion &lt;- vuelos %&gt;% filter(!is.na(codigo_cola)) %&gt;% distinct(aerolinea, codigo_cola) Podría darse el caso en que una aerolínea vende algunos de sus aviones a otra. Estos aviones tendrán una cuenta mayor a uno en la tabla anterior. aerolinea_avion %&gt;% count(codigo_cola) %&gt;% filter(n &gt; 1) %&gt;% nrow() ## [1] 17 Veamos ahora las transferencias de aviones entre aerolíneas. aviones_transferidos &lt;- aerolinea_avion %&gt;% # conservo los aviones que han volado para mas de una aerolinea group_by(codigo_cola) %&gt;% filter(n() &gt; 1) %&gt;% # uno los codigos con los nombres de aerolinea left_join(aerolineas, by = &quot;aerolinea&quot;) %&gt;% arrange(aerolinea, codigo_cola) aviones_transferidos ## # A tibble: 34 x 3 ## # Groups: codigo_cola [17] ## aerolinea codigo_cola nombre ## &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; ## 1 9E N146PQ Endeavor Air Inc. ## 2 9E N153PQ Endeavor Air Inc. ## 3 9E N176PQ Endeavor Air Inc. ## 4 9E N181PQ Endeavor Air Inc. ## 5 9E N197PQ Endeavor Air Inc. ## 6 9E N200PQ Endeavor Air Inc. ## 7 9E N228PQ Endeavor Air Inc. ## 8 9E N232PQ Endeavor Air Inc. ## 9 DL N933AT Delta Air Lines Inc. ## 10 DL N935AT Delta Air Lines Inc. ## # … with 24 more rows 11.6 Problemas de las uniones Los datos con los que has estado trabajando en este capítulo han sido limpiados de modo que tengas el mínimo de problemas posibles. Tus propios datos difícilmente estarán tan ordenados, por lo que hay algunas consideraciones y pasos a tener en cuenta para que las uniones sobre tus propios datos funcionen adecuadamente. Comienza identificando las variables que forman las llaves primarias en cada tabla. Usualmente debieras hacerlo basado en tus conocimientos de los datos, no observando empíricamente las combinaciones de variables que resultan en un identificador único. Si te centras en las variables sin pensar en sus significados, puedes tener la mala suerte de encontrar una combinación única en tus datos pero dicha relación puede no ser válida en general. Por ejemplo, la altura y la longitud identifican de manera única cada aeropuerto, ¡pero no son buenos identificadores! aeropuertos %&gt;% count(altura, longitud) %&gt;% filter(n &gt; 1) ## # A tibble: 0 x 3 ## # … with 3 variables: altura &lt;int&gt;, longitud &lt;dbl&gt;, n &lt;int&gt; Verifica que ninguna de las variables en la llave primaria esté perdida. ¡Si un valor está perdido no puede identificar una observación! Verifica que las llaves foráneas coinciden con las llaves primarias en otra tabla. La mejor forma de hacerlo es mediante anti_join(). Es común que las llaves no coincidan debido a errores en la entrada de datos. Arreglar este problema requiere mucho trabajo. Si tienes llaves perdidas, debes ser cuidadoso respecto del uso de unión interior versus unión exterior y considerar cuidadosamente si quieres descartar las observaciones que no tienen coincidencias. Ten en cuenta que verificiar el número de filas antes y después de unir no es suficiente para asegurar que la unión funcionó de forma exitosa. Si tienes una unión interior con llaves duplicadas en ambas tablas, puedes tener la mala suerte de que el número de filas descartadas sea igual al número de filas duplicadas. "],
["cadenas-de-caracteres.html", "12 Cadenas de caracteres 12.1 Cadenas: elementos básicos 12.2 Herramientas 12.3 Otro tipo de patrones 12.4 stringi", " 12 Cadenas de caracteres 12.1 Cadenas: elementos básicos 12.1.1 Ejercicios En ejemplos de código en los que no se utiliza stringr, verás usualmente paste() y paste0() (paste = pegar). ¿Cuál es la diferencia entre estas dos funciones? ¿A qué función de stringr son equivalentes? ¿Cómo difieren estas dos funciones respecto de su manejo de los NA? Describe con tus propias palabras la diferencia entre los argumentos sep y collapse de la función str_c(). Utiliza str_length() y str_sub() para extraer el caracter del medio de una cadena. ¿Qué harías si el número de caracteres es par? ¿Qué hace str_wrap()? (wrap = envolver) ¿Cuándo podrías querer utilizarla? ¿Qué hace str_trim()? (trim = recortar) ¿Cuál es el opuesto de str_trim()? Escribe una función que convierta, por ejemplo, el vector c(&quot;a&quot;, &quot;b&quot;, &quot;c&quot;) en la cadena a, b, y c. Piensa con detención qué debería hacer dado un vector de largo 0, 1, o 2. 12.1.2 Buscar coincidencia de patrones con expresiones regulares 12.1.2.1 Ejercicios Explica por qué cada una de estas cadenas no coincide con \\: &quot;\\&quot;, &quot;\\\\&quot;, &quot;\\\\\\&quot;. ¿Cómo harías coincidir la secuencia &quot;'\\? ¿Con qué patrones coincidiría la expresión regular\\..\\..\\..? ¿Cómo la representarías en una cadena? 12.1.3 Anclas 12.1.3.1 Ejercicios ¿Cómo harías coincidir la cadena &quot;$^$&quot; de manera literal? Dado el corpus de palabras comunes en datos::palabras, crea una expresión regular que busque palabras que: Empiecen con “y”. Terminen con “x” Tengan una extensión de exactamente tres letras. (¡No hagas trampa usando str_length()!) Tengan siete letras o más. Dado que esta será una lista larga, podrías quere usar el argumento match en str_view() para mostrar solo las palabras que coincidan o no coincidan. 12.1.4 Clases de caracteres y alternativas 12.1.4.1 Ejercicios Crea una expresión regular que encuentre todas las palabras que: Empiecen con una vocal. Solo contengan consonantes. (Pista: piensa en cómo buscar coincidencias para “no”-vocales.) Terminen en ón, pero no en ión. Terminen con ndo or ado. ¿Siempre a una “q” la sigue una “u”? Escribe una expresión regular que permita buscar un verbo que haya sido escrito usando voseo en segunda persona plural (por ejemplo, queréis en vez de quieren). Crea una expresión regular que coincida con la forma en que habitualmente se escriben los números de teléfono en tu país. En inglés existe una regla que dice que la letra i va siempre antes de la e, excepto cuando está después de una c&quot;. Verifica empíricamente esta regla utilizando las palabras contenidas en stringr::words. 12.1.5 Repetición 12.1.5.1 Ejercicios Describe los equivalentes de ?, +, * en el formato {m,n}. Describe en palabras con qué coincidiría cada una de estas expresiones regulares: (lee con atención para ver si estamos utilizando una expresión regular o una cadena que define una expresión regular.) ^.*$ &quot;\\\\{.+\\\\}&quot; \\d{4}-\\d{2}-\\d{2} &quot;\\\\\\\\{4}&quot; Crea expresiones regulares para buscar todas las palabras que: Empiecen con dos consonantes. Tengan tres o más vocales seguidas. Tengan tres o más pares de vocal-consonante seguidos. 12.1.6 Agrupamiento y referencias previas 12.1.6.1 Ejercicios Describe en palabras con qué coinciden estas expresiones: (.)\\1\\1 &quot;(.)(.)\\\\2\\\\1&quot; (..)\\1 &quot;(.).\\\\1.\\\\1&quot; &quot;(.)(.)(.).*\\\\3\\\\2\\\\1&quot; Construye una expresión regular que coincida con palabras que: Empiecen y terminen con el mismo caracter. Contengan un par de letras repetido (p. ej. “nacional” tiene “na” repetidos dos veces.) Contengan una letra repetida en al menos tres lugares (p. ej. “característica” tiene tres “a”.) 12.2 Herramientas 12.2.1 Ejercicios Para cada uno de los siguientes desafíos, intenta buscar una solución utilizando tanto una expresión regular simple como una combinación de múltiples llamadas a str_detect(). Encuentra todas las palabras que empiezan o terminan con y. Encuentra todas las palabras que empiezan con una vocal y terminan con una consonante. ¿Existen palabras que tengan todas las vocales? ¿Qué palabra tiene el mayor número de vocales? ¿Qué palabra tiene la mayor proporción de vocales? (Pista: ¿cuál es el denominador?) 12.2.2 Extraer coincidencias 12.2.2.1 Ejercicios Te habrás dado cuenta que en el ejemplo anterior la expresión regular que utilizamos también devolvió como resultado “arrojo” y “azulejos”, que no son nombres de colores. Modifica la expresión regular para resolver ese problema. De datos::oraciones extrae: La primera palabra de cada oración. Todas las palabras que terminen en ción. Todos los plurales. 12.2.3 Coincidencias agrupadas 12.2.3.1 Ejercicios Busca en datos::oraciones todas las palabras que vengan después de un “número”, como “un(o|a)”, “dos”, “tres”, etc. Extrae tanto el número como la palabra. En español a veces se utiliza el guión para unir adjetivos, establecer relaciones entre conceptos o para unir gentilicios (p. ej., teórico-práctico, precio-calidad, franco-porteño). ¿Cómo podrías encontrar esas palabras y separar lo que viene antes y después del guión? 12.2.4 Remplazar coincidencias 12.2.4.1 Ejercicios Remplaza en una cadena todas las barras por barras invertidas. Implementa una versón simple de str_to_lower() (a minúsculas) usando replace_all(). Cambia la primera y la última letra en palabras. ¿Cuáles de esas cadenas siguen siendo palabras? 12.2.5 Divisiones 12.2.5.1 Ejercicios Divide una cadena como &quot;manzanas, peras y bananas&quot; en elementos individuales. ¿Por qué es mejor dividir utilizando boundary(&quot;word&quot;) en vez de &quot; &quot;? ¿Qué pasa si dividimos con una cadena vacía (&quot;&quot;)? Experimenta y luego lee la documentación 12.3 Otro tipo de patrones 12.3.1 Ejercicios ¿Cómo buscarías todas las cadenas que contienen \\ con regex() vs. con fixed()? ¿Cuáles son las cinco palabras más comunes en oraciones? 12.4 stringi 12.4.1 Ejercicios Busca la función de stringi que: Cuenta el número de palabras. Busca cadenas duplicadas. Genera texto aleatorio. ¿Cómo puedes controlar qué lengua usa stri_sort() para ordenar? "],
["factores.html", "13 Factores 13.1 Encuesta social general 13.2 Modificar el orden de los factores 13.3 Modificar los niveles de los factores", " 13 Factores 13.1 Encuesta social general 13.1.1 Ejercicios Explora la distribución de ingreso. ¿Qué hace que el gráfico de barras por defecto sea tan difícil de comprender? ¿Cómo podrías mejorarlo? ¿Cuál es la religion más común de la encuesta? ¿Cuál es el partido más común? ¿A qué religion se aplica cada denominacion? ¿Cómo puedes encontrarlo con una tabla? ¿Cómo lo puedes descubrir con una visualización? 13.2 Modificar el orden de los factores 13.2.1 Ejercicios Hay algunos números sospechosamente grandes en horas_tv. ¿Es la media un buen resumen? Identifica, para cada factor en encuesta, si el orden de los niveles es arbitrario o responde a algún principio. ¿Por qué mover “No aplica” al inicio de los niveles lo llevó al final del gráfico? 13.3 Modificar los niveles de los factores 13.3.1 Ejercicios ¿Cómo han cambiado en el tiempo las proporciones de personas que se identifican como Demócratas, Republicanas e Independientes? ¿Cómo podrías colapsar ingreso en un grupo más pequeño de categorías? "],
["horas-y-fechas.html", "14 Horas y fechas 14.1 Creando horas/fechas 14.2 Componentes fecha-hora 14.3 Plazos de tiempo", " 14 Horas y fechas 14.1 Creando horas/fechas 14.1.1 Ejercicios ¿Qué sucede si analizas una cadena de caracteres que contiene fechas inválidas? ymd(c(&quot;2010-10-10&quot;, &quot;bananas&quot;)) ¿Qué hace el argumento tzone (del inglés, huso horario abreviado) para today()? ¿Por qué es importante? Usa la función de lubridate apropiada para analizar las siguientes fechas: d1 &lt;- &quot;Enero 1, 2010&quot; d2 &lt;- &quot;2015-Mar-07&quot; d3 &lt;- &quot;06-Jun-2017&quot; d4 &lt;- c(&quot;Agosto 19 (2015)&quot;, &quot;Julio 1 (2015)&quot;) d5 &lt;- &quot;12/30/14&quot; # Diciembre 30, 2014 14.2 Componentes fecha-hora 14.2.1 Ejercicios ¿Cómo cambia la distribución de las horas de los vuelos dentro de un día, a lo largo del año? Compara horario_salida, salida_programada and atraso_salida. ¿Son consistentes? Explica tus hallazgos. Compara tiempo_vuelo con la duración entre la salida y la llegada. Explica tus hallazgos. (Pista: considera la ubicación del aeropuerto). ¿Cómo cambia la demora promedio durante el curso de un día? ¿Deberías usar horario_salida o salida_programada? ¿Por qué? ¿En qué día de la semana deberías salir, si quieres minimizar las posibilidades de una demora? ¿Qué hace que la distribución de diamantes$carat y vuelos$salida_programada sean similares? Confirma mi hipótesis de que salidas programas en los minutos 20-30 y 50-60 están casuadas por los vuelos programados que salen más temprano. Pista: crea una variable binaria que te diga si un vuelo tuvo o no demora. 14.3 Plazos de tiempo 14.3.1 Ejercicios ¿Por qué hay months() pero no dmonths() (del inglés, días del mes)? Explica days(nocturno * 1) a alguien que apenas comienza a aprender R. ¿Cómo funciona? Crea un vector de fechas dando el primer día de cada mes en 2015. Crea un vector de fechas dando el primer día de cada mes del año actual. Crea una función en la cual, dado tu cumpleaños (como una fecha), retorne cuán viejo eres en años. ¿Por qué no puedes hacer funcionar a (today() %--% (today() + years(1)) / months(1) ? "],
["funciones.html", "15 Funciones 15.1 ¿Cuándo deberías escribir una función? 15.2 Las funciones son para los humanos y las computadoras 15.3 Ejecución condicional 15.4 Function arguments", " 15 Funciones 15.1 ¿Cuándo deberías escribir una función? 15.1.1 Práctica ¿Por qué TRUE no es un parámetro para rescale01()? ¿Qué pasaría si x está contenido en un valor único perdido y na.rm fuese FALSE? En la segunda variante de rescale01(), los valores infinitos se dejan sin cambio. Reescribe rescale01() así -Inf is convertido a 0, y Inf es convertido a 1. Practica convertir los siguientes fragmentos de código en funciones. Piensa en lo que hace cada función. ¿Cómo lo llamarías? ¿Cuántos argumentos necesita? ¿Puedes reescribirlo para ser más expresivo o menos duplicado? mean(is.na(x)) x / sum(x, na.rm = TRUE) sd(x, na.rm = TRUE) / mean(x, na.rm = TRUE) Sigue http://nicercode.github.io/intro/writing-functions.html para escribir tus propias funciones para computar la variancia y el sesgo de un vector numérico. Escribe both_na(), una función que toma dos vectores de la misma longitud y retorna el número de posiciones que tiene NA en ambos vectores. ¿Qué hacen las siguientes funciones? ¿Por qué son tan útiles aún cuando son tan cortas? is_directory &lt;- function(x) file.info(x)$isdir is_readable &lt;- function(x) file.access(x, 4) == 0 Lee el complete lyrics de “Pequeño conejito Foo Foo”. There’s a lot of duplication in this song. Extiende el ejemplo inicial de pipes para recrear la canción completa, usar las funciones para reducir la duplicación. 15.2 Las funciones son para los humanos y las computadoras 15.2.1 Ejercicios Lee el código fuente para cada una de las siguientes tres funciones, interpreta que hacen, y luego propone nombres mejores. f1 &lt;- function(string, prefix) { substr(string, 1, nchar(prefix)) == prefix } f2 &lt;- function(x) { if (length(x) &lt;= 1) return(NULL) x[-length(x)] } f3 &lt;- function(x, y) { rep(y, length.out = length(x)) } Toma una función que hayas escrito recientemente y tómate 5 minutos para pensar un mejor nombre para la función y para sus argumentos. Compara y contrasta rnorm() y MASS::mvrnorm(). ¿Cómo podrías hacerlas más consistentes? Argumenta porqué norm_r(),norm_d() etc sería una mejor opción que rnorm(), dnorm(). Argumenta lo contrario. 15.3 Ejecución condicional 15.3.1 Ejercicios ¿Cuál es la diferencia entre if and ifelse()? Lea cuidadosamente la ayuda y construya tres ejemplos que ilustren las diferencias claves. Escriba una función de saludo que diga “buenos días”, “buenas tardes” o “buenas noches”, según la hora del día. (Sugerencia: use un argumento de tiempo que por defecto es lubridate::now(), eso hará que sea más fácil probar su función). Implemente una función fizzbuzz. Toma un solo número como entrada. Si el número es divisible por tres, devuelve “fizz”. Si es divisible por cinco, devuelve “buzz”. Si es divisible por tres y cinco, devuelve “fizzbuzz”. De lo contrario, devuelve el número. Asegúrese de escribir primero el código de trabajo antes de crear la función. ¿Cómo podría usar cut() para simplificar una sentencia if-else anidada? if (temp &lt;= 0) { &quot;freezing&quot; } else if (temp &lt;= 10) { &quot;cold&quot; } else if (temp &lt;= 20) { &quot;cool&quot; } else if (temp &lt;= 30) { &quot;warm&quot; } else { &quot;hot&quot; } ¿Cómo cambiarías la sentencia a cut() si hubieras usado &lt;en lugar de &lt;=? ¿Cuál es la otra ventaja principal de cut() para este problema? (Sugerencia: ¿qué sucede si tienes muchos valores en temp?) ¿Qué sucedería si usaras switch() con un valor numérico? ¿Qué haría la sentencia switch()? ¿Qúe sucedería si x fuera “e”? switch(x, a = , b = &quot;ab&quot;, c = , d = &quot;cd&quot; ) Experimente, luego lea cuidadosamente la documentación. 15.4 Function arguments 15.4.1 Ejercicios ¿Qué realizan las commas(letters, collapse = &quot;-&quot;)? ¿Por qué? Sería bueno si se pudiera suplantar múltiples caracteres al argumento pad, ej., rule(&quot;Title&quot;, pad = &quot;-+&quot;). ¿Por qué esto actualmente no funciona? ¿Cómo podrías solucionarlo? ¿Qué realiza el argumento trim a la función mean()? ¿Cuándo podrías utilizarla? El valor de defecto para el argumento method a cor() es c(&quot;pearson&quot;, &quot;kendall&quot;, &quot;spearman&quot;). ¿Qué significa esto? ¿Qué valor se utiliza por defecto? "],
["vectores.html", "16 Vectores 16.1 Tipos importantes de vectores atómicos 16.2 Usando vectores atómicos 16.3 Vectores Recursivos (listas) 16.4 Vectores Aumentados", " 16 Vectores 16.1 Tipos importantes de vectores atómicos ###Ejercicios Describe la diferencia entre is.finite(x) y !is.infinite(x). Lee el código fuente de dplyr:: near() (Consejo: para ver el código fuente, escribe lo siguiente ()) ¿Funcionó? Un vector de tipo lógico puede tomar 3 valores posibles. ¿Cuántos valores posibles puede tomar un vector de tipo entero? ¿Cuántos valores posibles puede tomar un vector de tipo real? Usa google para realizar buscar información respecto a lo planteado anteriormente. Idea al menos 4 funciones que te permitan convertir un vector del tipo real a entero. ¿En qué difieren las funciones? Sé preciso. ¿Cuáles funciones del paquete readr te permiten convertir un vector del tipo string en un vector del tipo lógico, entero y doble? 16.2 Usando vectores atómicos 16.2.1 Ejercicios La expresión mean(is.na(x)), ¿qué dice acerca del vector ‘x’? ¿y qué sucede con la expresión sum(!is.finite(x))? Detenidamente lee la documentación de is.vector(). ¿Para qué se prueba la función realmente? ¿Por qué la función is.atomic() no concuerda con la definición de vectores atómicos vista anteriormente? Compara y contraste setNames() con purrr::set_names(). Crea funciones que tomen un vector como entrada y devuelva: El último valor. ¿Deberás usar [ o [[?. Los elementos en posiciones pares. Cada elemento excepto el último valor. Sólo las posiciones pares (y sin valores perdidos (missing values)). ¿Por qué x[-which(x &gt; 0)] no es lo mismo que x[x &lt;= 0]? ¿Qué sucede cuando realizas un subset (subdivisión) con un entero positivo que es mayor que la longitud del vector? ¿Qué sucede cuando realizas un subset (subdivisión) con un nombre que no existe? 16.3 Vectores Recursivos (listas) 16.3.1 Ejercicios 1.Dibuja las listas siguientes como sets anidados: 1. `list(a, b, list(c, d), list(e, f))` 1. `list(list(list(list(list(list(a))))))` 1.¿Qué pasaría si subdividieras un tibble como si fuera una lista? ¿Cuáles son las principales diferencias entre una lista y un tibble? 16.4 Vectores Aumentados 16.4.1 Ejecicios: ¿Qué valor retorna la siguiente expresión hms::hms(3600)? ¿Cómo se muestra? ¿Cuál es la tipo primario sobre el cual se basa el vector aumentado? ¿Qué atributos utiliza el mismo? Intenta y crea un tibble que tenga columnas con diferentes longitudes ¿Qué es lo que ocurre? Teniendo en cuenta "],
["iteracion.html", "17 Iteración 17.1 Bucles for 17.2 Variaciones de bucles for 17.3 Bucles for vs. funcionales 17.4 Las funciones map (mapa en inglés) 17.5 Otros patrones para los loops for", " 17 Iteración 17.1 Bucles for 17.1.1 Ejercicios Escribir bucles for para: Calcular la media de cada columna en mtautos. Determinar el tipo de cada columna en vuelos. Calcular el número de valores únicos en cada columna de iris. Genera 10 normales aleatorias para cada valor de \\(\\mu = -10\\), \\(0\\), \\(10\\) y \\(100\\). Piensa en el resultado, la secuencia y el cuerpo antes de empezar a escribir el bucle. Elimina el bucle for en cada uno de los siguientes ejemplos tomando ventaja de una función existente que trabaja con vectores: out &lt;- &quot;&quot; for (x in letters) { out &lt;- stringr::str_c(out, x) } x &lt;- sample(100) sd &lt;- 0 for (i in seq_along(x)) { sd &lt;- sd + (x[i] - mean(x)) ^ 2 } sd &lt;- sqrt(sd / (length(x) - 1)) x &lt;- runif(100) out &lt;- vector(&quot;numeric&quot;, length(x)) out[1] &lt;- x[1] for (i in 2:length(x)) { out[i] &lt;- out[i - 1] + x[i] } Combina tus habilidades para escribir funciones y bucles for: Escribe un bucle for que imprima (prints()) la letra de la canción de niños “Cinco ranitas verdes”. Convierte la canción infantil “10 monitos saltaban en la cama” en una función. Generalizar a cualquier cantidad de monitos en cualquier estructura para dormir. Convierte la canción “99 botellas de cerveza en la pared” en una función. Generalizar a cualquier cantidad, de cualquier tipo de recipiente que contenga cualquier líquido sobre cualquier superficie. Es común ver bucles for que no preasignan la salida y en su lugar aumentan la longitud de un vector en cada paso: output &lt;- vector(&quot;integer&quot;, 0) for (i in seq_along(x)) { output &lt;- c(output, lengths(x[[i]])) } output ¿Cómo afecta esto el rendimiento? Diseña y ejecuta un experimento. 17.2 Variaciones de bucles for 17.2.1 Ejercicios Imaginemos que tenemos un directorio lleno de archivos CSV que queremos leer. Tenemos sus ubicaciones en un vector, files &lt;- dir(&quot;data/&quot;, pattern = &quot;\\\\.csv$&quot;, full.names = TRUE), y ahora queremos leer cada uno con read_csv(). Escribe un bucle for que los cargue en un solo data frame. ¿Qué pasa si utilizamos for (nm in names(x)) y x no tiene names? ¿Qué pasa si solo algunos elementos están nombrados (named en inglés) ¿Qué pasa si los nombres (names en inglés) no son únicos? Escribe una función que imprima el promedio de cada columna numérica en un data frame, junto con su nombre. Por ejemplo, mostrar_promedio(iris) debe imprimir: mostrar_promedio(iris) #&gt; Sepal.Length: 5.84 #&gt; Sepal.Width: 3.06 #&gt; Petal.Length: 3.76 #&gt; Petal.Width: 1.20 (Desafío adicional: ¿qué función utilizamos para asegurarnos que los números queden alineados a pesar que los nombres de las variables tienen diferentes longitudes?) ¿Qué hace este código? ¿cómo funciona? trans &lt;- list( disp = function(x) x * 0.0163871, am = function(x) { factor(x, labels = c(&quot;auto&quot;, &quot;manual&quot;)) } ) for (var in names(trans)) { mtcars[[var]] &lt;- trans[[var]](mtcars[[var]]) } 17.3 Bucles for vs. funcionales 17.3.1 Ejercicios Lee la documentación para apply (). En el caso 2d, ¿qué dos bucles for generaliza? Adapta col_summary () para que solo se aplique a las columnas numéricas. Es posible que desees comenzar con la función is_numeric () que devuelve un vector lógico que tenga un TRUE por cada columna numérica. 17.4 Las funciones map (mapa en inglés) 17.4.1 Ejercicios Escribe un código que use una de las funciones de map para: Calcular la media de cada columna en mautos. Obtener de que tipo es cada columna en vuelos. Calcular la cantidad de valores únicos en cada columna de iris. Generar diez normales aleatorias para cada \\(\\mu = -10\\), \\(0\\), \\(10\\), and \\(100\\). ¿Cómo puedes crear un vector tal que para cada columna en un cuadro de datos indique si corresponde o no a un factor? ¿Qué ocurre si usas las funciones map en vectores que no son listas? ¿Qué hace map(1:5, runif)? ¿Por qué? ¿Qué hace map(-2:2, rnorm, n = 5)? ¿Por qué? ¿Qué hace map_dbl(-2:2, rnorm, n = 5)? ¿Por qué? Reescribe map(x, function(df) lm(mpg ~ wt, data = df)) para eliminar todas las funciones anónimas. 17.5 Otros patrones para los loops for 17.5.1 Ejercicios Implementa tu propia versión de every() usando un loop for. Comparala con purrr::every(). ¿Qué hace la versión de purrr que la tuya no hace? Crea una mejora de col_sum() que aplique una función de resumen a cada columna numérica en un data frame. Un posible equivalente de col_sum() es: col_sum3 &lt;- function(df, f) { is_num &lt;- sapply(df, is.numeric) df_num &lt;- df[, is_num] sapply(df_num, f) } Pero tiene una cantidad de bugs que queda ilustrada con las siguientes entradas: df &lt;- tibble( x = 1:3, y = 3:1, z = c(&quot;a&quot;, &quot;b&quot;, &quot;c&quot;) ) # OK col_sum3(df, mean) # Has problems: don&#39;t always return numeric vector col_sum3(df[1:2], mean) col_sum3(df[1], mean) col_sum3(df[0], mean) ¿Cuál es la causa de esos bugs? "],
["model-intro.html", "18 Introducción", " 18 Introducción Este capítulo no tiene ejercicios "],
["modelos-conceptos-basicos.html", "19 Modelos: conceptos básicos 19.1 Paquetes necesarios 19.2 Un modelo simple 19.3 Visualizando modelos 19.4 Fórmulas y familias de modelos", " 19 Modelos: conceptos básicos 19.1 Paquetes necesarios library(tibble) library(ggplot2) library(purrr) library(modelr) library(tidyr) library(dplyr) ## ## Attaching package: &#39;dplyr&#39; ## The following objects are masked from &#39;package:stats&#39;: ## ## filter, lag ## The following objects are masked from &#39;package:base&#39;: ## ## intersect, setdiff, setequal, union library(stringr) 19.2 Un modelo simple 19.2.1 Ejercicios Una desventaja del modelo lineal es ser sensible a valores inusuales debido a que la distancia incorpora un término al cuadrado. Ajusta un modelo a los datos simulados que se presentan a continuación y visualiza los resultados. Corre el modelo varias veces para generar diferentes conjuntos de datos simulados. ¿Qué puedes observar respecto del modelo? sim1a &lt;- tibble( x = rep(1:10, each = 3), y = x * 1.5 + 6 + rt(length(x), df = 2) ) Solución Se puede correr una vez y graficar los resultados. ggplot(sim1a, aes(x = x, y = y)) + geom_point() + geom_smooth(method = &quot;lm&quot;, se = FALSE) Para sistematizarlo, se pueden generar varias simulaciones y luego graficar las líneas. simt &lt;- function(i) { tibble( x = rep(1:10, each = 3), y = x * 1.5 + 6 + rt(length(x), df = 2), .id = i ) } sims &lt;- map_df(1:12, simt) ggplot(sims, aes(x = x, y = y)) + geom_point() + geom_smooth(method = &quot;lm&quot;, colour = &quot;red&quot;) + facet_wrap(~.id, ncol = 4) El ejercicio usa la función rt() la cual entrega un muestreo a partir de una distribución t-Student, la cual tiene colas más largas que la distribución normal (rnorm()), por lo tanto asigna una mayor probabilidad a los valores fuera del centro de la distribución. ¿Qué ocurre si usamos una distribución normal? sim_norm &lt;- function(i) { tibble( x = rep(1:10, each = 3), y = x * 1.5 + 6 + rnorm(length(x)), .id = i ) } simdf_norm &lt;- map_df(1:12, sim_norm) ggplot(simdf_norm, aes(x = x, y = y)) + geom_point() + geom_smooth(method = &quot;lm&quot;, colour = &quot;red&quot;) + facet_wrap(~.id, ncol = 4) Al usar distribución normal no hay tantos valores extremos y las pendientes son más similares. Para el caso de la distribución normal con media cero y desviación estándar uno, la probabilidad de que un valor sea mayor a dos se obtiene con pnorm(). pnorm(2, lower.tail = FALSE) ## [1] 0.02275013 Para el caso de la distribución t-Student con dos grados de libertad, la probabilidad es más del triple del caso anterior y se obtiene con pt(). pt(2, df = 2, lower.tail = FALSE) ## [1] 0.09175171 Podemos concluir que el modelo es sensible a valores extremos y en general a la distribución que siguen los datos. Una forma de obtener un modelo lineal más robusto es usar una métrica distinta para la distancia. Por ejemplo, en lugar de la raíz de la distancia media cuadrática (del inglés root-mean-squared distance) se podría usar la media de la distancia absoluta: medir_distancia &lt;- function(modelo, datos) { diferencia &lt;- datos$y - modelo1(modelo, datos) mean(abs(diferencia)) } Usa optim() para ajustar este modelo a los datos simulados anteriormente y compara el resultado con el modelo lineal. Solución Usando los datos sim1a y optim() podemos encontrar los parámetros que minimizan la desviación absoluta. Definiremos la función modelo1() tal como se hizo en el libro. modelo1 &lt;- function(a, datos) { a[1] + datos$x * a[2] } beta &lt;- optim(c(0, 0), medir_distancia, datos = sim1a) beta$par ## [1] 6.735896 1.338399 Los resultados del modelo lineal son los mismos que se obtienen si se minimiza la desviación al cuadrado. medir_distancia_ml &lt;- function(modelo, datos) { diferencia &lt;- datos$y - (modelo[1] + modelo[2] * datos$x) sqrt(mean(diferencia^2)) } beta &lt;- optim(c(0, 0), medir_distancia_ml, datos = sim1a) beta$par ## [1] 7.167235 1.320816 En la práctica no es recomendable usar optim() para ajustar un modelo, es mejor utilizar implementaciones ya existentes como rlm() y lqs() que son parte del paquete MASS. La justificación es que estas implementaciones permiten ajustar modelos robustos sin los múltiples problemas de carácter numérico que pueden surgir de manera condicional a los datos al momento de usar optim(). Un desafío al realizar optimización numérica es que únicamente garantiza encontrar un óptimo local. ¿Qué problema se presenta al optimizar un modelo de tres parámetros como el que se presenta a continuación? modelo3 &lt;- function(a, datos) { a[1] + datos$x * a[2] + a[3] } Solución El problema es que dados los valores a[1] = a1 y a[3] = a3, cualquier otra combinación de a[1] y a[3] tal que a[1] + a[3] == (a1 + a3) tendrá el mismo ajuste. medir_distancia_3_ml &lt;- function(a, datos) { diferencia &lt;- datos$y - modelo3(a, datos) sqrt(mean(diferencia^2)) } Dependiendo de los valores inciales se van a obtener distintos valores óptimos. beta_000 &lt;- optim(c(0, 0, 0), medir_distancia_3_ml, datos = sim1a) beta_000$par ## [1] -7.762092 1.321104 14.927988 beta_001 &lt;- optim(c(0, 0, 1), medir_distancia_3_ml, datos = sim1a) beta_001$par ## [1] -12.053431 1.321067 19.219143 beta_005 &lt;- optim(c(0, 0, 5), medir_distancia_3_ml, datos = sim1a) beta_005$par ## [1] 2.522685 1.320835 4.643837 Si seguimos alterando los valores inciales no es muy difícil concluir que existen infinitos valores óptimos para este modelo. 19.3 Visualizando modelos 19.3.1 Ejercicios En lugar de usar lm() para ajustar una línea recta, puedes usar loess() para ajustar una curva suave. Repite el proceso de ajustar el modelo, generar la cuadrícula, predicciones y visualización con sim1 usando loess() en vez de lm(). ¿Cómo se compara el resultado a geom_smooth(). Solución Usando add_predictions() y add_residuals() se pueden agregar las predicciones y los residuos de la regresión loess a los datos sim1a. sim1_loess &lt;- loess(y ~ x, data = sim1a) sim1_lm &lt;- lm(y ~ x, data = sim1a) grid_loess &lt;- sim1a %&gt;% add_predictions(sim1_loess) sim1a &lt;- sim1a %&gt;% add_residuals(sim1_lm) %&gt;% add_predictions(sim1_lm) %&gt;% add_residuals(sim1_loess, var = &quot;resid_loess&quot;) %&gt;% add_predictions(sim1_loess, var = &quot;pred_loess&quot;) Ahora procedemos a graficar las predicciones. La regresión loess genera un ajuste no lineal a partir de los datos. plot_sim1_loess &lt;- ggplot(sim1, aes(x = x, y = y)) + geom_point() + geom_line(aes(x = x, y = pred), data = grid_loess, colour = &quot;red&quot;) plot_sim1_loess Las predicciones del modelo loess son las mismas que entrega el método por defecto de geom_smooth() ya que este usa loess() y entrega un mensaje al respecto. plot_sim1_loess + geom_smooth(method = &quot;loess&quot;, colour = &quot;blue&quot;, se = FALSE, alpha = 0.20) Podemos graficar los residuos de loess (en rojo) y compararlos con los del modelo lineal (en negro). En general, el modelo loess tiene un menor residuo dada la muestra (fuera de la muestra no se asegura este comportamiento y no hemos considerado la incertidumbre de la estimación). ggplot(sim1a, aes(x = x)) + geom_ref_line(h = 0) + geom_point(aes(y = resid)) + geom_point(aes(y = resid_loess), colour = &quot;red&quot;) add_predictions() está pareada con gather_predictions() y spread_predictions(). ¿Cómo difieren estas tres funciones? Solución Las funciones gather_predictions() y spread_predictions() permiten incluir simultáneamente las predicciones de múltiples modelos. Por ejemplo, se puede incluir sim1_mod. sim1_mod &lt;- lm(y ~ x, data = sim1) grid &lt;- sim1 %&gt;% data_grid(x) La función add_predictions() permite incluir un modelo a la vez. Para agregar dos modelos se debe encadenar con el operador %&gt;%. grid %&gt;% add_predictions(sim1_mod, var = &quot;pred_lm&quot;) %&gt;% add_predictions(sim1_loess, var = &quot;pred_loess&quot;) ## # A tibble: 10 x 3 ## x pred_lm pred_loess ## &lt;int&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 1 6.27 9.05 ## 2 2 8.32 9.78 ## 3 3 10.4 10.7 ## 4 4 12.4 11.8 ## 5 5 14.5 13.3 ## 6 6 16.5 15.1 ## 7 7 18.6 16.9 ## 8 8 20.6 18.3 ## 9 9 22.7 19.2 ## 10 10 24.7 19.7 La función gather_predictions() incorpora predicciones de múltiples modelos por medio de agrupar los resultados e incluir una columna con el nombre del modelo. grid %&gt;% gather_predictions(sim1_mod, sim1_loess) ## # A tibble: 20 x 3 ## model x pred ## &lt;chr&gt; &lt;int&gt; &lt;dbl&gt; ## 1 sim1_mod 1 6.27 ## 2 sim1_mod 2 8.32 ## 3 sim1_mod 3 10.4 ## 4 sim1_mod 4 12.4 ## 5 sim1_mod 5 14.5 ## 6 sim1_mod 6 16.5 ## 7 sim1_mod 7 18.6 ## 8 sim1_mod 8 20.6 ## 9 sim1_mod 9 22.7 ## 10 sim1_mod 10 24.7 ## 11 sim1_loess 1 9.05 ## 12 sim1_loess 2 9.78 ## 13 sim1_loess 3 10.7 ## 14 sim1_loess 4 11.8 ## 15 sim1_loess 5 13.3 ## 16 sim1_loess 6 15.1 ## 17 sim1_loess 7 16.9 ## 18 sim1_loess 8 18.3 ## 19 sim1_loess 9 19.2 ## 20 sim1_loess 10 19.7 La función spread_predictions() incorpora predicciones de múltiples modelos agregando múltiples columnas (de acuerdo al nombre de cada modelo) que contienen las predicciones respectivas. grid %&gt;% spread_predictions(sim1_mod, sim1_loess) ## # A tibble: 10 x 3 ## x sim1_mod sim1_loess ## &lt;int&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 1 6.27 9.05 ## 2 2 8.32 9.78 ## 3 3 10.4 10.7 ## 4 4 12.4 11.8 ## 5 5 14.5 13.3 ## 6 6 16.5 15.1 ## 7 7 18.6 16.9 ## 8 8 20.6 18.3 ## 9 9 22.7 19.2 ## 10 10 24.7 19.7 La función spread_predictions() es similar a correr add_predictions() para cada modelo que se quiere incorporar y es equivalente a correr spread() luego de gather_predictions(). grid %&gt;% gather_predictions(sim1_mod, sim1_loess) %&gt;% spread(model, pred) ## # A tibble: 10 x 3 ## x sim1_loess sim1_mod ## &lt;int&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 1 9.05 6.27 ## 2 2 9.78 8.32 ## 3 3 10.7 10.4 ## 4 4 11.8 12.4 ## 5 5 13.3 14.5 ## 6 6 15.1 16.5 ## 7 7 16.9 18.6 ## 8 8 18.3 20.6 ## 9 9 19.2 22.7 ## 10 10 19.7 24.7 ¿Qué hace geom_ref_line()? ¿De qué paquete proviene? ¿Por qué es útil e importante incluir una línea de referencia en los gráficos que muestran residuos? Solución La geometría geom_ref_line() agrega una línea de referencia al gráfico. Es el equivalente a usar geom_hline() o geom_vline() con las opciones por defecto y que nos sirven para visualizar modelos. Agregar una línea de referencia en torno a cero para los residuos es importante ya que un buen modelo, por lo general, tiene residuos centrados en torno a cero. Otras características relevantes son que los errores deben tener idéntica varianza y no estar correlacionados entre si. La línea de referencia en torno a cero permite evaluar visualmente estas características. ¿Por qué quisieras mirar un polígono de frecuencias con los residuos absolutos? ¿Cuáles son las ventajas y desventajas de los residuos crudos? Solución Mostrar los valores absolutos de los residuos facilita ver la magnitud del error. El modelo lineal asume que los residuos tienen media cero y usar los valores absolutos de los residuos permite ver lo que ocurre cuando los errores de signos opuestos no se cancelan mutuamente. sim1_mod &lt;- lm(y ~ x, data = sim1a) sim1 &lt;- sim1 %&gt;% add_residuals(sim1_mod) ggplot(sim1a, aes(x = abs(resid))) + geom_freqpoly(binwidth = 0.5) El inconveniente que aparece visualmente es que se pierde toda información respecto de los signos de los residuos. Por lo tanto, el polígono de frecuencias no distingue si acaso el modelo sobre-estima o sub-estima de manera consistente. 19.4 Fórmulas y familias de modelos 19.4.1 Ejercicios ¿Qué pasa si repites el análisis de sim2 usando un modelo sin intercepto? ¿Qué ocurre con la ecuación del modelo? ¿Qué ocurre con las predicciones? Solución Para estimar el modelo sin intercepto agregamos -1 o +0 al lado derecho de la fórmula. mod2a &lt;- lm(y ~ x - 1, data = sim2) mod2 &lt;- lm(y ~ x, data = sim2) Las predicciones son las mismas en el caso con o sin intercepto: grid &lt;- sim2 %&gt;% data_grid(x) %&gt;% spread_predictions(mod2, mod2a) grid ## # A tibble: 4 x 3 ## x mod2 mod2a ## &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 a 1.15 1.15 ## 2 b 8.12 8.12 ## 3 c 6.13 6.13 ## 4 d 1.91 1.91 Usa model_matrix() para explorar las ecuaciones generadas por los modelos ajustados a sim3 y sim4. ¿Por qué * es un atajo para la interacción? Solución El caso x1 * x2 cuando x2 es una variable categórica produce las variables binarias x2b, x2c y x2d y las variables continuas x1:x2b, x1:x2c y x1:x2d que son el producto de x1 y x2*. x3 &lt;- model_matrix(y ~ x1 * x2, data = sim3) x3 ## # A tibble: 120 x 8 ## `(Intercept)` x1 x2b x2c x2d `x1:x2b` `x1:x2c` `x1:x2d` ## &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 1 1 0 0 0 0 0 0 ## 2 1 1 0 0 0 0 0 0 ## 3 1 1 0 0 0 0 0 0 ## 4 1 1 1 0 0 1 0 0 ## 5 1 1 1 0 0 1 0 0 ## 6 1 1 1 0 0 1 0 0 ## 7 1 1 0 1 0 0 1 0 ## 8 1 1 0 1 0 0 1 0 ## 9 1 1 0 1 0 0 1 0 ## 10 1 1 0 0 1 0 0 1 ## # … with 110 more rows Podemos confirmar que las variables x1:x2b son el producto de x1 y x2b. all(x3[[&quot;x1:x2b&quot;]] == (x3[[&quot;x1&quot;]] * x3[[&quot;x2b&quot;]])) ## [1] TRUE Es similar para x1:x2c y x2c como para el caso de x1:x2d y x2d. all(x3[[&quot;x1:x2c&quot;]] == (x3[[&quot;x1&quot;]] * x3[[&quot;x2c&quot;]])) ## [1] TRUE all(x3[[&quot;x1:x2d&quot;]] == (x3[[&quot;x1&quot;]] * x3[[&quot;x2d&quot;]])) ## [1] TRUE Para x1 * x2 cuando x1 y x2 son continuas, model_matrix() creas las variables x1, x2 y x1:x2. x4 &lt;- model_matrix(y ~ x1 * x2, data = sim4) x4 ## # A tibble: 300 x 4 ## `(Intercept)` x1 x2 `x1:x2` ## &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 1 -1 -1 1 ## 2 1 -1 -1 1 ## 3 1 -1 -1 1 ## 4 1 -1 -0.778 0.778 ## 5 1 -1 -0.778 0.778 ## 6 1 -1 -0.778 0.778 ## 7 1 -1 -0.556 0.556 ## 8 1 -1 -0.556 0.556 ## 9 1 -1 -0.556 0.556 ## 10 1 -1 -0.333 0.333 ## # … with 290 more rows Se puede confirmar que x1:x2 es el producto de x1 y x2. all(x4[[&quot;x1&quot;]] * x4[[&quot;x2&quot;]] == x4[[&quot;x1:x2&quot;]]) ## [1] TRUE Usando los principios básicos, convierte las fórmulas de los siguientes modelos en funciones. (Sugerencia: comienza por convertir las variables categóricas en ceros y unos.) mod1 &lt;- lm(y ~ x1 + x2, data = sim3) mod2 &lt;- lm(y ~ x1 * x2, data = sim3) Solución El lado derecho de las fórmulas se encarga de generar una matriz de diseño a partir de las columnas x1 y x2, lo que se ve reflejado en model_matrix(). Veamos los niveles de x2, que por ser una variable categórica es la más compleja de llevar a la matriz de diseño. x1 permanece inalterada. levels(sim3$x2) ## [1] &quot;a&quot; &quot;b&quot; &quot;c&quot; &quot;d&quot; Para el caso ~ x1 + x2 lo que haremos es considerar “a” como el nivel de referencia, por lo que se omite, y luego generamos nuevas columnas para los niveles “b”, “c” y “d”. model_matrix_mod1 &lt;- function(.data) { mutate(.data, x2b = as.numeric(x2 == &quot;b&quot;), x2c = as.numeric(x2 == &quot;c&quot;), x2d = as.numeric(x2 == &quot;d&quot;), `(Intercept)` = 1 ) %&gt;% select(`(Intercept)`, x1, x2b, x2c, x2d) } model_matrix_mod1(sim3) ## # A tibble: 120 x 5 ## `(Intercept)` x1 x2b x2c x2d ## &lt;dbl&gt; &lt;int&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 1 1 0 0 0 ## 2 1 1 0 0 0 ## 3 1 1 0 0 0 ## 4 1 1 1 0 0 ## 5 1 1 1 0 0 ## 6 1 1 1 0 0 ## 7 1 1 0 1 0 ## 8 1 1 0 1 0 ## 9 1 1 0 1 0 ## 10 1 1 0 0 1 ## # … with 110 more rows Es posible crear función para ~ x1 + x2 que no depende de los niveles específicos de x2. model_matrix_mod1b &lt;- function(.data) { # niveles de x2 lvls &lt;- levels(.data$x2) # borramos el primer nivel (es de referencia) # asumimos que hay al menos dos niveles lvls &lt;- lvls[2:length(lvls)] # creamos una variable binaria para cada nivel de x2 for (lvl in lvls) { varname &lt;- str_c(&quot;x2&quot;, lvl) .data[[varname]] &lt;- as.numeric(.data$x2 == lvl) } # generamos una lista de las variables que se mantienen x2_variables &lt;- str_c(&quot;x2&quot;, lvls) # agregamos el intercepto .data[[&quot;(Intercept)&quot;]] &lt;- 1 # mantenemos las variables binarias x1 y x2 select(.data, `(Intercept)`, x1, one_of(x2_variables)) } model_matrix_mod1b(sim3) ## # A tibble: 120 x 5 ## `(Intercept)` x1 x2b x2c x2d ## &lt;dbl&gt; &lt;int&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 1 1 0 0 0 ## 2 1 1 0 0 0 ## 3 1 1 0 0 0 ## 4 1 1 1 0 0 ## 5 1 1 1 0 0 ## 6 1 1 1 0 0 ## 7 1 1 0 1 0 ## 8 1 1 0 1 0 ## 9 1 1 0 1 0 ## 10 1 1 0 0 1 ## # … with 110 more rows Para el caso ~ x1 * x2 hay que tener en cuenta que debemos generar una columna por cada nivel de x2, sin contar el nivel de referencia que interactúa con x1. model_matrix_mod2 &lt;- function(.data) { mutate(.data, `(Intercept)` = 1, x2b = as.numeric(x2 == &quot;b&quot;), x2c = as.numeric(x2 == &quot;c&quot;), x2d = as.numeric(x2 == &quot;d&quot;), `x1:x2b` = x1 * x2b, `x1:x2c` = x1 * x2c, `x1:x2d` = x1 * x2d ) %&gt;% select(`(Intercept)`, x1, x2b, x2c, x2d, `x1:x2b`, `x1:x2c`, `x1:x2d`) } model_matrix_mod2(sim3) ## # A tibble: 120 x 8 ## `(Intercept)` x1 x2b x2c x2d `x1:x2b` `x1:x2c` `x1:x2d` ## &lt;dbl&gt; &lt;int&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 1 1 0 0 0 0 0 0 ## 2 1 1 0 0 0 0 0 0 ## 3 1 1 0 0 0 0 0 0 ## 4 1 1 1 0 0 1 0 0 ## 5 1 1 1 0 0 1 0 0 ## 6 1 1 1 0 0 1 0 0 ## 7 1 1 0 1 0 0 1 0 ## 8 1 1 0 1 0 0 1 0 ## 9 1 1 0 1 0 0 1 0 ## 10 1 1 0 0 1 0 0 1 ## # … with 110 more rows Es posible crear una función para ~ x1 * x2 que no depende de los niveles específicos de x2. model_matrix_mod2b &lt;- function(.data) { # partimos de la base del modelo x1 + x2 out &lt;- model_matrix_mod1b(.data) # tomamos las columnas que contienen &quot;x2&quot; x2cols &lt;- str_subset(colnames(out), &quot;^x2&quot;) # creamos las variables de interacción for (varname in x2cols) { newvar &lt;- str_c(&quot;x1:&quot;, varname) out[[newvar]] &lt;- out$x1 * out[[varname]] } out } model_matrix_mod2b(sim3) ## # A tibble: 120 x 8 ## `(Intercept)` x1 x2b x2c x2d `x1:x2b` `x1:x2c` `x1:x2d` ## &lt;dbl&gt; &lt;int&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 1 1 0 0 0 0 0 0 ## 2 1 1 0 0 0 0 0 0 ## 3 1 1 0 0 0 0 0 0 ## 4 1 1 1 0 0 1 0 0 ## 5 1 1 1 0 0 1 0 0 ## 6 1 1 1 0 0 1 0 0 ## 7 1 1 0 1 0 0 1 0 ## 8 1 1 0 1 0 0 1 0 ## 9 1 1 0 1 0 0 1 0 ## 10 1 1 0 0 1 0 0 1 ## # … with 110 more rows Estas funciones se podrían generalizar para los casos en que x1 y x2 pueden ser de tipo numérico o categórico. Si seguimos generalizando acabaremos reescribiendo la función matrix_model(). Para sim4, ¿Es mejor mod1 o mod2? Yo creo que mod2 es ligeramente mejor removiendo las tendencias, pero es bastante sutil. ¿Puedes generar un gráfico que de sustento a esta hipótesis? Solución Estimamos los modelos mod1 y mod2 a partir de sim4, mod1 &lt;- lm(y ~ x1 + x2, data = sim4) mod2 &lt;- lm(y ~ x1 * x2, data = sim4) Luego agregamos los residuos a los datos de sim4. sim4_mods &lt;- gather_residuals(sim4, mod1, mod2) Ahora podemos generar un gráfico de frecuencias de los residuos y los valores absolutos de estos. ggplot(sim4_mods, aes(x = resid, colour = model)) + geom_freqpoly(binwidth = 0.5) + geom_rug() ggplot(sim4_mods, aes(x = abs(resid), colour = model)) + geom_freqpoly(binwidth = 0.5) + geom_rug() Esto no muestra una gran diferencia. Sin embargo, mod2 parece tener menos residuos en las colas de la distribución entre 2,5 y 5, aunque los residuos más extremos son los de este modelo. Podemos verificar lo anterior calculando la desviación estándar de los residuos para cada modelo. sim4_mods %&gt;% group_by(model) %&gt;% summarise(resid = sd(resid)) ## # A tibble: 2 x 2 ## model resid ## &lt;chr&gt; &lt;dbl&gt; ## 1 mod1 2.10 ## 2 mod2 2.07 La desviación estándar de los residuos de mod2 es menor que la de mod1. "],
["model-building.html", "20 Model building", " 20 Model building ¡AGREGAR CUANDO ESTÉ TRADUCIDO! "],
["muchos-modelos.html", "21 Muchos modelos 21.1 Paquetes necesarios 21.2 gapminder 21.3 Creando columnas-lista 21.4 Simplificando columnas-lista", " 21 Muchos modelos 21.1 Paquetes necesarios library(dplyr) ## ## Attaching package: &#39;dplyr&#39; ## The following objects are masked from &#39;package:stats&#39;: ## ## filter, lag ## The following objects are masked from &#39;package:base&#39;: ## ## intersect, setdiff, setequal, union library(tidyr) library(purrr) library(modelr) library(ggplot2) library(ggbeeswarm) library(stringr) library(datos) 21.2 gapminder 21.2.1 Ejercicios Una tendencia lineal parece ser demasiado simple para la tendencia general. ¿Puedes hacerlo mejor con un polinomio cuadrático? ¿Cómo puedes interpretar el coeficiente del término cuadrático? (Pista: puedes querer transformar year para que tenga media cero.) Solución El siguiente código replica el análisis que se hizo en el libro pero cambia l función modelo_pais() para incluir una regresión que incluye el año al cuadrado. modelo_pais_2 &lt;- function(df) { lm(esperanza_de_vida ~ poly(anio - median(anio), 2), data = df) } por_pais &lt;- paises %&gt;% group_by(pais, continente) %&gt;% nest() por_pais &lt;- por_pais %&gt;% mutate(modelo = map(data, modelo_pais_2)) por_pais &lt;- por_pais %&gt;% mutate( residuo = map2(data, modelo, add_residuals) ) por_pais ## # A tibble: 142 x 5 ## pais continente data modelo residuo ## &lt;fct&gt; &lt;fct&gt; &lt;list&gt; &lt;list&gt; &lt;list&gt; ## 1 Afganistán Asia &lt;tibble [12 × 4]&gt; &lt;lm&gt; &lt;tibble [12 × 5]&gt; ## 2 Albania Europa &lt;tibble [12 × 4]&gt; &lt;lm&gt; &lt;tibble [12 × 5]&gt; ## 3 Argelia África &lt;tibble [12 × 4]&gt; &lt;lm&gt; &lt;tibble [12 × 5]&gt; ## 4 Angola África &lt;tibble [12 × 4]&gt; &lt;lm&gt; &lt;tibble [12 × 5]&gt; ## 5 Argentina Américas &lt;tibble [12 × 4]&gt; &lt;lm&gt; &lt;tibble [12 × 5]&gt; ## 6 Australia Oceanía &lt;tibble [12 × 4]&gt; &lt;lm&gt; &lt;tibble [12 × 5]&gt; ## 7 Austria Europa &lt;tibble [12 × 4]&gt; &lt;lm&gt; &lt;tibble [12 × 5]&gt; ## 8 Baréin Asia &lt;tibble [12 × 4]&gt; &lt;lm&gt; &lt;tibble [12 × 5]&gt; ## 9 Bangladesh Asia &lt;tibble [12 × 4]&gt; &lt;lm&gt; &lt;tibble [12 × 5]&gt; ## 10 Bélgica Europa &lt;tibble [12 × 4]&gt; &lt;lm&gt; &lt;tibble [12 × 5]&gt; ## # … with 132 more rows unnest(por_pais, residuo) %&gt;% ggplot(aes(anio, resid)) + geom_line(aes(group = pais), alpha = 1 / 3) + geom_smooth(se = FALSE) ## `geom_smooth()` using method = &#39;gam&#39; and formula &#39;y ~ s(x, bs = &quot;cs&quot;)&#39; por_pais %&gt;% mutate(estadistica = map(modelo, broom::glance)) %&gt;% unnest(estadistica, .drop = TRUE) %&gt;% ggplot(aes(continente, r.squared)) + geom_jitter(width = 0.5) Explora otros métodos para visualizar la distribución del \\(R^2\\) por continente. Puedes querer probar el paquete ggbeeswarm, que provee métodos similares para evitar superposiciones como jitter, pero usa métodos determinísticos. Solución El paquete gbeeswarm se usó en el capítulo de análisis exploratorio. por_pais %&gt;% mutate(estadistica = map(modelo, broom::glance)) %&gt;% unnest(estadistica, .drop = TRUE) %&gt;% ggplot(aes(continente, r.squared)) + geom_beeswarm() Para crear el último gráfico (mostrando los datos para los países con los peores ajustes del modelo), precisamos dos pasos: creamos un data frame con una fila por país y después hicimos un semi-join (del inglés semi juntar) (TODO: deberíamos aclarar algo?) al conjunto de datos original. Es posible evitar este join si usamos unnest() en lugar de unnest(.drop = TRUE). ¿Cómo? Solución paises %&gt;% group_by(pais, continente) %&gt;% nest() %&gt;% mutate(modelo = map(data, ~lm(esperanza_de_vida ~ anio, .))) %&gt;% mutate(estadistica = map(modelo, broom::glance)) %&gt;% unnest(estadistica) %&gt;% unnest(data) %&gt;% filter(r.squared &lt; 0.25) %&gt;% ggplot(aes(anio, esperanza_de_vida)) + geom_line(aes(color = pais)) 21.3 Creando columnas-lista 21.3.1 Ejercicios Lista todas las funciones en las que puedas pensar que tomen como input un vector atómico y retornen una lista. Solución Muchas funciones del paquete stringr cumplen con el criterio. str_split(sentences[1:3], &quot; &quot;) ## [[1]] ## [1] &quot;The&quot; &quot;birch&quot; &quot;canoe&quot; &quot;slid&quot; &quot;on&quot; &quot;the&quot; &quot;smooth&quot; ## [8] &quot;planks.&quot; ## ## [[2]] ## [1] &quot;Glue&quot; &quot;the&quot; &quot;sheet&quot; &quot;to&quot; &quot;the&quot; ## [6] &quot;dark&quot; &quot;blue&quot; &quot;background.&quot; ## ## [[3]] ## [1] &quot;It&#39;s&quot; &quot;easy&quot; &quot;to&quot; &quot;tell&quot; &quot;the&quot; &quot;depth&quot; &quot;of&quot; &quot;a&quot; &quot;well.&quot; str_match_all(c(&quot;paul&quot;, &quot;john&quot;, &quot;george&quot;, &quot;ringo&quot;), &quot;a+&quot;) ## [[1]] ## [,1] ## [1,] &quot;a&quot; ## ## [[2]] ## [,1] ## ## [[3]] ## [,1] ## ## [[4]] ## [,1] En el caso del paquete purrr, la función map() también cumple el criterio. map(1:3, runif) ## [[1]] ## [1] 0.5790991 ## ## [[2]] ## [1] 0.8556076 0.7929767 ## ## [[3]] ## [1] 0.1954186 0.8156963 0.5177822 Piensa en funciones de resumen útiles que, como quantile(), retornen múltiples valores. Solución Algunos ejemplos de funciones básicas de R que cumplen con el criterio. range(mtcars$mpg) ## [1] 10.4 33.9 fivenum(mtcars$mpg) ## [1] 10.40 15.35 19.20 22.80 33.90 boxplot.stats(mtcars$mpg) ## $stats ## [1] 10.40 15.35 19.20 22.80 33.90 ## ## $n ## [1] 32 ## ## $conf ## [1] 17.11916 21.28084 ## ## $out ## numeric(0) ¿Qué es lo que falta en el siguiente data frame? ¿Cómo quantile() retorna eso que falta? ¿Por qué eso no es tan útil aquí? mtautos %&gt;% group_by(cilindros) %&gt;% summarise(q = list(quantile(millas))) %&gt;% unnest() ## # A tibble: 15 x 2 ## cilindros q ## &lt;dbl&gt; &lt;dbl&gt; ## 1 4 21.4 ## 2 4 22.8 ## 3 4 26 ## 4 4 30.4 ## 5 4 33.9 ## 6 6 17.8 ## 7 6 18.6 ## 8 6 19.7 ## 9 6 21 ## 10 6 21.4 ## 11 8 10.4 ## 12 8 14.4 ## 13 8 15.2 ## 14 8 16.2 ## 15 8 19.2 Solución No se muestran los cuartiles correspondientes. Esto se debe a que la función quantile() entrega los valores 0%, 25%, 50%, 75%, 100% como nombres del vector resultante y unnest() descarta los nombres del vector. quantile(mtcars$mpg) ## 0% 25% 50% 75% 100% ## 10.400 15.425 19.200 22.800 33.900 ¿Qué hace este código? ¿Por qué podría ser útil? mtautos %&gt;% group_by(cilindros) %&gt;% summarise_each(funs(list)) Solución Crea un cuadro de datos en el que cada fila corresponde a un valor unico de cilindros y cada observación fuera de la primera columna es un vector. La utilidad es que reune las observaciones para cada variable y las agrupa, lo que puede simplificar algunos análisis particulares en los que se quiera analizar todas las observaciones agrupando por número de cilindros. 21.4 Simplificando columnas-lista 21.4.1 Ejercicios ¿Por qué podría ser útil la función lengths() para crear columnas de vectores atómicos a partir de columnas-lista? Solución La función lengths() entreg el largo de cada elemento en una lista. Proporciona un atajo a map_int(x, length) y sapply(x, length). Es útil para verificar si acaso los elementos de una columna de tipo lista son todos del mismo largo. Otra posibilidad es calcular el máximo largo dentro de la columna y así sabremos cuántas columnas debo crear para transformar en varias columnas atómicas. Lista los tipos de vectores más comúnes que se encuentran en un data frame. ¿Qué hace que las listas sean diferentes? Solución Los tipos más comunes de vectores en un cuadro de datos son: logical numeric integer character factor Todos estos tipos son atómicos. Las listas no son atómicas ya que pueden contener otras listas o vectores. "],
["r-markdown.html", "22 R Markdown 22.1 R Markdown básico 22.2 Formateo de texto con Markdown 22.3 Bloques de código", " 22 R Markdown 22.1 R Markdown básico 22.1.1 Ejercicios Crea un nuevo notebook usando File &gt; New File &gt; R Notebook. Lee las instrucciones. Practica ejecutando los bloques. Verifica que puedes modificar el código, re-ejecútalo, y observa la salida modificada. Crea un nuevo documento R Markdown con File &gt; New File &gt; R Markdown… Haz clic en el icono apropiado de Knit. Haz Knit usando el atajo de teclado apropiado. Verifica que puedes modificar el input y la actualizacion del output. Compara y contrasta el notebook de R con los archivos de R markdown que has creado antes. ¿Cómo son similares los outputs? ¿Cómo son diferentes? ¿Cómo son similares los inputs? ¿En qué se diferencian? ¿Qué ocurre si copias el encabezado YAML de uno al otro? Crea un nuevo documento R Markdown para cada uno de los tres formatos incorporados: HTML, PDF and Word. Haz knit en cada uno de estos tres documentos. ¿Como difiere el output? ¿Cómo difiere el input? (Puedes necesitar instalar LaTeX para poder compilar el output en PDF— RStudio preguntará si esto es necesario). 22.2 Formateo de texto con Markdown 22.2.1 Ejercicios Practica lo que has aprendido crando un CV breve. El título debería ser tu nombre, y deberías incluir encabezados para (por lo menos) educación o empleo. Cada una de las secciones debería incluir una lista con viñetas de trabajos/ títulos obtenidos. Resalta año en negrita. Usando la referencia rapida de R Markdown, descubre como: Agregar una nota al pie. Agregar una linea horizontal. Agregar una cita en bloque. Copia y pega los contenidos de diamond-sizes.Rmd desde https://github.com/hadley/r4ds/tree/master/rmarkdown a un documento local de R Markdown. Revisa que puedes ejecutarlo, agrega texto despues del poligono de frecuencias que describa sus características más llamativas. 22.3 Bloques de código 22.3.1 Ejercicios Incluye una seccion que explore como los tamaños de diamantes varian por corte, color y claridad. Asume que escribes un reporte para alguien que no conoce R, y en lugar de fijar echo = FALSE en cada bloque, fijar una opción global. Descarga diamond-sizes.Rmd de https://github.com/hadley/r4ds/tree/master/rmarkdown. Agrega una sección que describa los 20 diamantes mas grandes, incluyendo una tabla que muestre sus atributos más importantes. Modifica diamonds-sizes.Rmd para usar comma() para producir un formato de output ordenado. También incluye el porcentaje de diamantes que son mayores a 2.5 quilates. Fija una red de bloques donde d depende de c y b, y tanto b y c dependen de a. Haz que cada bloque imprima lubridate::now(), fijar cache = TRUE, y verifica entonces tu comprensión del almacenamiento en cache. "],
["comunicar-con-graficos.html", "23 Comunicar con gráficos 23.1 Paquetes necesarios 23.2 Etiquetas 23.3 Anotaciones 23.4 Escalas", " 23 Comunicar con gráficos 23.1 Paquetes necesarios library(ggplot2) library(datos) 23.2 Etiquetas 23.2.1 Ejercicios Crea un gráfico partiendo de los datos de economía de combustible con etiquetas para title , subtitle, caption, x, y y color personalizadas. La función geom_smooth() es un poco engañosa porque autopista está sesgada positivamente para motores grandes, debido a la inclusión de autos deportivos livianos con motores grandes. Usa tus herramientas de modelado para ajustar y mostrar un modelo mejor. Elige un gráfico exploratorio que hayas creado en el último mes y agrégale títulos informativos para volverlo más fácil de comprender para otros. 23.3 Anotaciones 23.3.1 Ejercicios Usa las infinitas posiciones que permite geom_text() para colocar texto en cada una de las cuatro esquinas del gráfico. Lee la documentación de la función annotate(). ¿Cómo puedes usarla para agregar una etiqueta de texto a un gráfico sin tener que crear un tibble? ¿Cómo interactúan las etiquetas producidas por geom_text() con la separación en facetas? ¿Cómo puedes agregar una etiqueta a una sola faceta? ¿Cómo puedes poner una etiqueta diferente en cada faceta? (Sugerencia: piensa en los datos subyacentes). ¿Qué argumentos para geom_label() controlan la apariencia de la caja que se ve atrás? ¿Cuáles son los cuatro argumentos de arrow()? ¿Cómo funcionan? Crea una serie de gráficos que demuestren las opciones más importantes. 23.4 Escalas 23.4.1 Ejercicios ¿Por qué el siguiente código no reemplaza la escala predeterminada? ggplot(df, aes(x, y)) + geom_hex() + scale_colour_gradient(low = &quot;white&quot;, high = &quot;red&quot;) + coord_fixed() ¿Cuál es el primer argumento para cada escala? ¿Cómo se compara con labs()? Cambia la visualización de los términos presidenciales de las siguientes maneras: Combinando las dos variantes que se muestran arriba. Mejorando la visualización del eje y. Etiquetando cada término con el nombre del presidente. Agregandoetiquetas informativas al gráfico. Poniendo intervalos de 4 años (¡esto es más complicado de lo que parece!). Utiliza override.aes para que la leyenda en el siguiente gráfico sea más fácil de ver: ggplot(diamantes, aes(quilate, precio)) + geom_point(aes(colour = corte, alpha = 1 / 20)) "],
["r-markdown-formats.html", "24 R Markdown formats", " 24 R Markdown formats ¡Agregar cuando esté traducido! (Aunque parece que no tiene ejercicios) "]
]
