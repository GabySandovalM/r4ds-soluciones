[
["muchos-modelos.html", "21 Muchos modelos 21.1 Paquetes necesarios 21.2 gapminder 21.3 Creando columnas-lista 21.4 Simplificando columnas-lista", " 21 Muchos modelos 21.1 Paquetes necesarios library(dplyr) ## ## Attaching package: &#39;dplyr&#39; ## The following objects are masked from &#39;package:stats&#39;: ## ## filter, lag ## The following objects are masked from &#39;package:base&#39;: ## ## intersect, setdiff, setequal, union library(tidyr) library(purrr) library(modelr) library(ggplot2) library(ggbeeswarm) library(stringr) library(datos) 21.2 gapminder 21.2.1 Ejercicios Una tendencia lineal parece ser demasiado simple para la tendencia general. ¿Puedes hacerlo mejor con un polinomio cuadrático? ¿Cómo puedes interpretar el coeficiente del término cuadrático? (Pista: puedes querer transformar year para que tenga media cero.) Solución El siguiente código replica el análisis que se hizo en el libro pero cambia l función modelo_pais() para incluir una regresión que incluye el año al cuadrado. modelo_pais_2 &lt;- function(df) { lm(esperanza_de_vida ~ poly(anio - median(anio), 2), data = df) } por_pais &lt;- paises %&gt;% group_by(pais, continente) %&gt;% nest() por_pais &lt;- por_pais %&gt;% mutate(modelo = map(data, modelo_pais_2)) por_pais &lt;- por_pais %&gt;% mutate( residuo = map2(data, modelo, add_residuals) ) por_pais ## # A tibble: 142 x 5 ## pais continente data modelo residuo ## &lt;fct&gt; &lt;fct&gt; &lt;list&gt; &lt;list&gt; &lt;list&gt; ## 1 Afganistán Asia &lt;tibble [12 × 4]&gt; &lt;lm&gt; &lt;tibble [12 × 5]&gt; ## 2 Albania Europa &lt;tibble [12 × 4]&gt; &lt;lm&gt; &lt;tibble [12 × 5]&gt; ## 3 Argelia África &lt;tibble [12 × 4]&gt; &lt;lm&gt; &lt;tibble [12 × 5]&gt; ## 4 Angola África &lt;tibble [12 × 4]&gt; &lt;lm&gt; &lt;tibble [12 × 5]&gt; ## 5 Argentina Américas &lt;tibble [12 × 4]&gt; &lt;lm&gt; &lt;tibble [12 × 5]&gt; ## 6 Australia Oceanía &lt;tibble [12 × 4]&gt; &lt;lm&gt; &lt;tibble [12 × 5]&gt; ## 7 Austria Europa &lt;tibble [12 × 4]&gt; &lt;lm&gt; &lt;tibble [12 × 5]&gt; ## 8 Baréin Asia &lt;tibble [12 × 4]&gt; &lt;lm&gt; &lt;tibble [12 × 5]&gt; ## 9 Bangladesh Asia &lt;tibble [12 × 4]&gt; &lt;lm&gt; &lt;tibble [12 × 5]&gt; ## 10 Bélgica Europa &lt;tibble [12 × 4]&gt; &lt;lm&gt; &lt;tibble [12 × 5]&gt; ## # … with 132 more rows unnest(por_pais, residuo) %&gt;% ggplot(aes(anio, resid)) + geom_line(aes(group = pais), alpha = 1 / 3) + geom_smooth(se = FALSE) ## `geom_smooth()` using method = &#39;gam&#39; and formula &#39;y ~ s(x, bs = &quot;cs&quot;)&#39; por_pais %&gt;% mutate(estadistica = map(modelo, broom::glance)) %&gt;% unnest(estadistica, .drop = TRUE) %&gt;% ggplot(aes(continente, r.squared)) + geom_jitter(width = 0.5) Explora otros métodos para visualizar la distribución del \\(R^2\\) por continente. Puedes querer probar el paquete ggbeeswarm, que provee métodos similares para evitar superposiciones como jitter, pero usa métodos determinísticos. Solución El paquete gbeeswarm se usó en el capítulo de análisis exploratorio. por_pais %&gt;% mutate(estadistica = map(modelo, broom::glance)) %&gt;% unnest(estadistica, .drop = TRUE) %&gt;% ggplot(aes(continente, r.squared)) + geom_beeswarm() Para crear el último gráfico (mostrando los datos para los países con los peores ajustes del modelo), precisamos dos pasos: creamos un data frame con una fila por país y después hicimos un semi-join (del inglés semi juntar) (TODO: deberíamos aclarar algo?) al conjunto de datos original. Es posible evitar este join si usamos unnest() en lugar de unnest(.drop = TRUE). ¿Cómo? Solución paises %&gt;% group_by(pais, continente) %&gt;% nest() %&gt;% mutate(modelo = map(data, ~lm(esperanza_de_vida ~ anio, .))) %&gt;% mutate(estadistica = map(modelo, broom::glance)) %&gt;% unnest(estadistica) %&gt;% unnest(data) %&gt;% filter(r.squared &lt; 0.25) %&gt;% ggplot(aes(anio, esperanza_de_vida)) + geom_line(aes(color = pais)) 21.3 Creando columnas-lista 21.3.1 Ejercicios Lista todas las funciones en las que puedas pensar que tomen como input un vector atómico y retornen una lista. Solución Muchas funciones del paquete stringr cumplen con el criterio. str_split(sentences[1:3], &quot; &quot;) ## [[1]] ## [1] &quot;The&quot; &quot;birch&quot; &quot;canoe&quot; &quot;slid&quot; &quot;on&quot; &quot;the&quot; &quot;smooth&quot; ## [8] &quot;planks.&quot; ## ## [[2]] ## [1] &quot;Glue&quot; &quot;the&quot; &quot;sheet&quot; &quot;to&quot; &quot;the&quot; ## [6] &quot;dark&quot; &quot;blue&quot; &quot;background.&quot; ## ## [[3]] ## [1] &quot;It&#39;s&quot; &quot;easy&quot; &quot;to&quot; &quot;tell&quot; &quot;the&quot; &quot;depth&quot; &quot;of&quot; &quot;a&quot; &quot;well.&quot; str_match_all(c(&quot;paul&quot;, &quot;john&quot;, &quot;george&quot;, &quot;ringo&quot;), &quot;a+&quot;) ## [[1]] ## [,1] ## [1,] &quot;a&quot; ## ## [[2]] ## [,1] ## ## [[3]] ## [,1] ## ## [[4]] ## [,1] En el caso del paquete purrr, la función map() también cumple el criterio. map(1:3, runif) ## [[1]] ## [1] 0.8295914 ## ## [[2]] ## [1] 0.3837574 0.6047096 ## ## [[3]] ## [1] 0.7916436 0.9575736 0.6445145 Piensa en funciones de resumen útiles que, como quantile(), retornen múltiples valores. Solución Algunos ejemplos de funciones básicas de R que cumplen con el criterio. range(mtcars$mpg) ## [1] 10.4 33.9 fivenum(mtcars$mpg) ## [1] 10.40 15.35 19.20 22.80 33.90 boxplot.stats(mtcars$mpg) ## $stats ## [1] 10.40 15.35 19.20 22.80 33.90 ## ## $n ## [1] 32 ## ## $conf ## [1] 17.11916 21.28084 ## ## $out ## numeric(0) ¿Qué es lo que falta en el siguiente data frame? ¿Cómo quantile() retorna eso que falta? ¿Por qué eso no es tan útil aquí? mtautos %&gt;% group_by(cilindros) %&gt;% summarise(q = list(quantile(millas))) %&gt;% unnest() ## # A tibble: 15 x 2 ## cilindros q ## &lt;dbl&gt; &lt;dbl&gt; ## 1 4 21.4 ## 2 4 22.8 ## 3 4 26 ## 4 4 30.4 ## 5 4 33.9 ## 6 6 17.8 ## 7 6 18.6 ## 8 6 19.7 ## 9 6 21 ## 10 6 21.4 ## 11 8 10.4 ## 12 8 14.4 ## 13 8 15.2 ## 14 8 16.2 ## 15 8 19.2 Solución No se muestran los cuartiles correspondientes. Esto se debe a que la función quantile() entrega los valores 0%, 25%, 50%, 75%, 100% como nombres del vector resultante y unnest() descarta los nombres del vector. quantile(mtcars$mpg) ## 0% 25% 50% 75% 100% ## 10.400 15.425 19.200 22.800 33.900 ¿Qué hace este código? ¿Por qué podría ser útil? mtautos %&gt;% group_by(cilindros) %&gt;% summarise_each(funs(list)) Solución Crea un cuadro de datos en el que cada fila corresponde a un valor unico de cilindros y cada observación fuera de la primera columna es un vector. La utilidad es que reune las observaciones para cada variable y las agrupa, lo que puede simplificar algunos análisis particulares en los que se quiera analizar todas las observaciones agrupando por número de cilindros. 21.4 Simplificando columnas-lista 21.4.1 Ejercicios ¿Por qué podría ser útil la función lengths() para crear columnas de vectores atómicos a partir de columnas-lista? Solución La función lengths() entreg el largo de cada elemento en una lista. Proporciona un atajo a map_int(x, length) y sapply(x, length). Es útil para verificar si acaso los elementos de una columna de tipo lista son todos del mismo largo. Otra posibilidad es calcular el máximo largo dentro de la columna y así sabremos cuántas columnas debo crear para transformar en varias columnas atómicas. Lista los tipos de vectores más comúnes que se encuentran en un data frame. ¿Qué hace que las listas sean diferentes? Solución Los tipos más comunes de vectores en un cuadro de datos son: logical numeric integer character factor Todos estos tipos son atómicos. Las listas no son atómicas ya que pueden contener otras listas o vectores. "]
]
