# Datos relacionales

```{r}
library(dplyr)
library(datos)
```

## datos {#nycflights13-relational}

### Ejercicios

1. Imagina que necesitas dibujar (aproximadamente) la ruta que cada avión vuela 
 desde su origen hasta el destino. ¿Qué variables necesitas? ¿Qué tablas
 necesitas combinar?

<div class="solucion">
<h3>Solución</h3>

Necesitas combinar `aeropuertos` con `vuelos` ya que el dataset `aeropuertos` 
con tiene las coordenadas de los aeropuertos. Puedes unir las tablas por medio
de la variable `codigo_aeropuerto` en `aeropuertos` y `origen` y `destino` en
`vuelos`.

```{r}
vuelos %>%
  left_join(aeropuertos, by = c("origen" = "codigo_aeropuerto",
                                "destino" = "codigo_aeropuerto"))
```
</div>

1. Olvidamos incluir la relación entre `clima` y `aeropuertos`. ¿Cuál es la
 relación y cómo debe aparecer en el diagrama?

<div class="solucion">
<h3>Solución</h3>

De manera similar al ejercicio anterior, se pueden unir mediante
`codigo_aeropuerto` en `aeropuertos` y `origen` en `clima`.
</div>

1. `clima` únicamente contiene información de los aeropuertos de origen 
 (Nueva York). Si contuviera registros para todos los aeropuertos de EEUU, ¿Qué
 relación tendría con `vuelos`?

<div class="solucion">
<h3>Solución</h3>

Puedes conectar `clima` con `vuelos` usando la columna `destino` e incluir el
clima de los aeropuertos de EEUU que están presentes en la tabla `vuelos`.
</div>

1. Sabemos que hay días "especiales" en el año y pocas personas vuelan esos
 días. ¿Cómo se representarían en un data frame? ¿Cuáles serían las llaves
 primarias de esa tabla? ¿Cómo se conectaría con las tablas existentes?
   
<div class="solucion">
<h3>Solución</h3>

Una posibilidad es contar con un dataset de los días festivos en EEUU indicando
mes y día. Esta información se puede unir con cada vuelo en la tabla `vuelos` y
y a la vez con el dataset `clima`.
</div>

## Llaves

### Ejercicios

1. Agrega una llave sustituta a `vuelos`.

<div class="solucion">
<h3>Solución</h3>

```{r}
vuelos %>%
  mutate(id = row_number(anio)) %>%
  select(id, everything())
```
</div>

1. Identifica las llaves en los siguientes conjuntos de datos

 1. `datos::bateadores`
 1. `datos::nombres`
 1. `datos::atmosfera`
 1. `datos::vehiculos`
 1. `datos::diamantes`
  
 (Puede que necesites leer un poco de documentación.)

<div class="solucion">
<h3>Solución</h3>

 1. En `datos::bateadores` corresponde a `id_jugador`.
 1. En `datos::nombres` corresponde a la combinación de `anio` y `nombre`,
  con esto se puede unir cada par año-nombre con las otras tablas.
 1. En `datos::atmosfera` corresponde a  latitud`, `longitud`, `anio` y `mes`,
  lo cual identifica de manera única un lugar en el tiempo.
 1. En `datos::vehiculos` corresponde a `id`.
 1. En `datos::diamantes` no hay llaves ya que estas tienen sentido en datos
 relacionales, es decir cuando existen otras tablas para combinar información.
</div>

1. Dibuja un diagrama que ilustre las conexiones entre las tablas `bateadores`,
  `personas` y `salarios` en el paquete datos. Dibuja otro diagrama que muestre la
  relación entre `personas`, `dirigentes` y `premios_dirigentes`.

  ¿Cómo caracterizarías las relación entre `bateadores`, `lanzadores` y `fildeo`?

<div class="solucion">
<h3>Solución</h3>

Es directo. Las tres tablas contienen los campos `id_jugador` y `anio` y cada
tabla contiene información que complementa las demás. La relación es uno a uno.
</div>

## Uniones de transformación {#mutating-joins}

### Ejercicios

1. Calcula el atraso promedio por destino, luego une los datos en `aeropuertos` 
   para que puedas mostrar la distribución espacial de los atrasos. Te presentamos 
   una forma fácil de dibujar un mapa de los Estados Unidos:

 ```{r, eval = FALSE}
aeropuertos %>%
  semi_join(vuelos, c("codigo_aeropuerto" = "destino")) %>%
  ggplot(aes(longitud, latitud)) +
  borders("state") +
  geom_point() +
  coord_quickmap()
 ```

  (No te preocupes si no entiendes que hace `semi_join()`. 
  Lo aprenderás a continuación.)
  
  Quizás quieras usar `size` o `colour` para editar los puntos y mostrar 
  el atraso promedio de cada aeropuerto.
  
<div class="solucion">
<h3>Solución</h3>
```{r}
atraso_promedio_destino <- vuelos %>%
   group_by(destino) %>%
   # los vuelos con NA en atraso_llegada son vuelos cancelados
   summarise(atrado = mean(atraso_llegada, na.rm = TRUE)) %>%
   inner_join(aeropuertos, by = c(destino = "codigo_aeropuerto"))
```

```{r}
atraso_promedio_destino %>%
  ggplot(aes(longitud, latitud, colour = atraso)) +
  borders("state") +
  geom_point() +
  coord_quickmap()
```
</div>
 
1. Agrega la ubicación de origen _y_ destino (e.g. `latitud` y `longitud`) 
   a `vuelos`.

<div class="solucion">
<h3>Solución</h3>

Es posible realizar varias uniones. Si hay variables duplicadas, dplyr va a
distinguirlas agregando `.x` y `.y` al nombre de la variable para resolver
los nombres duplicados.

```{r}
ubicacion_aeropuertos <- aeropuertos %>%
  select(codigo_aeropuerto, latitud, longitud)

vuelos %>%
  select(anio:dia, hora, origen, destino) %>%
  left_join(
    ubicacion_aeropuertos,
    by = c("origen" = "codigo_aeropuerto")
  ) %>%
  left_join(
    ubicacion_aeropuertos,
    by = c("destino" = "codigo_aeropuerto")
  )
```

Es una buena práctica tener nombres indicativos para las variables. Usaremos
el sufijo `_destino` y `_origen` para especificar a qué aeropuerto nos referimos.

```{r}
vuelos %>%
  select(anio:dia, hora, origen, destino) %>%
  left_join(
    ubicacion_aeropuertos,
    by = c("origen" = "codigo_aeropuerto")
  ) %>%
  left_join(
    ubicacion_aeropuertos,
    by = c("destino" = "codigo_aeropuerto"),
    suffix = c("_origen", "_destino")
  )
```
</div>

1. ¿Existe una relación entre la antiguedad de un avión y sus atrasos?

<div class="solucion">
<h3>Solución</h3>

Ya que no se indica si se refiere a atrasos de salida o llegada, se explorará
el atraso en la salida, quedando el otro caso como ejercicio.

Para comparar la antiguedad de un avión con sus atrasos, hay que unir
`vuelos` con `aviones`, esta última tabla contiene la variable `anio` que se
refiere al año de fabricación del avión.

Dado que hay pocos aviones de más de 25 años, truncaremos los datos y luego
vamos a calcular el promedio de llegada y salida dada la antiguedad.

```{r}
plane_cohorts <- inner_join(vuelos,
   select(aviones, codigo_cola, anio_fabricacion = anio), by = "codigo_cola") %>%
   mutate(antiguedad = anio - anio_fabricacion) %>%
   filter(!is.na(antiguedad)) %>%
   mutate(antiguedad = if_else(antiguedad > 25, 25L, antiguedad)) %>%
   group_by(antiguedad) %>%
   summarise(
      prom_atraso_salida = mean(atraso_salida, na.rm = TRUE),
      desv_est_atraso_salida = sd(atraso_salida, na.rm = TRUE),
      prom_atraso_llegada = mean(atraso_llegada, na.rm = TRUE),
      desv_est_atraso_llegada = sd(atraso_llegada, na.rm = TRUE),
      nro_vuelos_atrasados_salida = sum(!is.na(atraso_salida)),
      nro_vuelos_atrasados_llegada = sum(!is.na(atraso_llegada))
   )
```

Ahora podemos explorar la reglación entre los atrasos en la salida y la
antiguedad.

El atraso en la salida es creciente en relación a la antiguedad para los
aviones de hasta de 10 años. Luego este atraso decae.

La reducción de los atrasos en la salida en relación a la antiguedad puede
deberse a que en los aviones más antiguos se planfica la mantención para evitar
tales atrasos y desperfectos mecánicos.

```{r}
ggplot(plane_cohorts, aes(x = age, y = dep_delay_mean)) +
  geom_point() +
  scale_x_continuous("Age of plane (years)", breaks = seq(0, 30, by = 10)) +
  scale_y_continuous("Mean Departure Delay (minutes)")
```
</div>

1. ¿Qué condiciones climáticas hacen más probables los atrasos?

1. ¿Qué sucedió el día 13 de junio de 2013? Muestra el patrón espacial de los atrasos, 
   luego usa un buscador para encontrar referencias cruzadas con el clima.

 ```{r, eval = FALSE, include = FALSE}
peores <- filter(vuelos, !is.na(horario_salida), mes == 6, dia == 13)
peores %>%
  group_by(destino) %>%
  summarise(atraso = mean(atraso_llegada), n = n()) %>%
  filter(n > 5) %>%
  inner_join(aeropuertos, by = c("destino" = "codigo_aeropuerto")) %>%
  ggplot(aes(longitud, latitud)) +
  borders("state") +
  geom_point(aes(size = n, colour = atraso)) +
  coord_quickmap()
 ```


## Uniones de filtro {#filtering-joins}

### Ejercicios

1. ¿Qué significa que in vuelo no tenga `codigo_cola`? ¿Qué tienen en común los códigos 
   de cola que no tienen registros coincidentes en `aviones`? (Pista: Una variable explica 
   ~90% de los problemas.)

1. Filtra los vuelos para mostrar únicamente los aviones que han realizado al menos cien
   viajes

1. Combina `vehiculos` y `comunes` para encontrar los registros de los 
   modelos más comunes.

1. Encuentra las 48 horas (en el transcurso del año) que tengan los peores atrasos. Haz 
   una referencia cruzada con la tabla `clima`. ¿Puedes observar patrones?

1. ¿Qué te indica `anti_join(vuelos, aeropuertos, by = c("destino" = "codigo_aeropuerto"))`?
   ¿Qué te indica `anti_join(aeropuertos, vuelos, by = c("codigo_aeropuerto" = "destino"))`?

1. Puedes esperar que exista una relación implícita entre aviones y aerolíneas, dado que cada 
   avión es operado por una única aerolínea. Confirma o descarta esta hipótesis usando las 
   herramientas que aprendiste más arriba.

## Problemas de las uniones

Los datos con los que has estado trabajando en este capítulo han sido limpiados de modo que tengas el mínimo de problemas posibles. Tus propios datos difícilmente estarán tan ordenados, por lo que hay algunas consideraciones y pasos a tener en cuenta para que las uniones sobre tus propios datos funcionen adecuadamente.

1. Comienza identificando las variables que forman las llaves primarias en cada tabla.
   Usualmente debieras hacerlo basado en tus conocimientos de los datos, no observando 
   empíricamente las combinaciones de variables que resultan en un identificador único. 
   Si te centras en las variables sin pensar en sus significados, puedes tener la mala 
   suerte de encontrar una combinación única en tus datos pero dicha relación puede no ser válida en general.

   Por ejemplo, la altura y la longitud identifican de manera única cada aeropuerto, ¡pero 
   no son buenos identificadores!

 ```{r}
aeropuertos %>% count(altura, longitud) %>% filter(n > 1)
 ```

1. Verifica que ninguna de las variables en la llave primaria esté perdida. 
   ¡Si un valor está perdido no puede identificar una observación!

1. Verifica que las llaves foráneas coinciden con las llaves primarias en 
   otra tabla. La mejor forma de hacerlo es mediante `anti_join()`. Es común 
   que las llaves no coincidan debido a errores en la entrada de datos. Arreglar 
   este problema requiere mucho trabajo.

   Si tienes llaves perdidas, debes ser cuidadoso respecto del uso de unión interior 
   versus unión exterior y considerar cuidadosamente si quieres descartar las observaciones 
   que no tienen coincidencias.
   
   Ten en cuenta que verificiar el número de filas antes y después de unir no es suficiente para asegurar 
   que la unión funcionó de forma exitosa. Si tienes una unión interior con llaves duplicadas en ambas tablas, 
   puedes tener la mala suerte de que el número de filas descartadas sea igual al número de filas duplicadas.

